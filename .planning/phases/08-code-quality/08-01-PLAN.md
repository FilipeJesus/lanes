---
phase: 08-code-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/FileService.ts
  - eslint.config.mjs
autonomous: true

must_haves:
  truths:
    - "FileService provides centralized async file I/O operations"
    - "ESLint bans synchronous fs methods (readFileSync, writeFileSync, existsSync, mkdirSync)"
    - "Atomic write pattern prevents file corruption"
    - "readJson returns null on ENOENT for consistent error handling"
  artifacts:
    - path: "src/services/FileService.ts"
      provides: "Centralized async file I/O operations"
      exports: ["atomicWrite", "readJson", "writeJson", "ensureDir", "fileExists", "readFile"]
      min_lines: 80
    - path: "eslint.config.mjs"
      provides: "Lint rules banning sync fs methods"
      contains: "no-restricted-syntax"
  key_links:
    - from: "src/services/*.ts"
      to: "src/services/FileService.ts"
      via: "import statements replacing direct fs operations"
      pattern: "import.*from.*FileService"
---

<objective>
Create FileService for centralized async file I/O and enhance ESLint to ban synchronous fs methods.

Purpose: Establish the foundation for consistent async file I/O throughout the codebase by providing a centralized service and enforcing async-only patterns through linting.

Output: FileService module with atomic writes, JSON handling, and ESLint rules that prevent sync fs usage.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-code-quality/08-RESEARCH.md

# Reference patterns from existing code
@src/mcp/tools.ts - Atomic write pattern (lines 40-48)
@src/services/SettingsService.ts - Async fs/promises usage (line 10)
</context>

<tasks>

<task type="auto">
  <name>Create FileService with async file I/O operations</name>
  <files>src/services/FileService.ts</files>
  <action>
Create `src/services/FileService.ts` with the following exports:

1. **atomicWrite(filePath, content)**: Write content atomically using temp-file-then-rename pattern
   - Write to `{filePath}.tmp.{process.pid}` first
   - Rename to target path (atomic operation)
   - Use fs.promises.writeFile and fs.promises.rename
   - Reference: Existing pattern in src/mcp/tools.ts lines 40-48

2. **readJson<T>(filePath)**: Read and parse JSON file
   - Use fs.promises.readFile with 'utf-8' encoding
   - Return null on ENOENT (file not found)
   - Re-throw other errors (permissions, parse errors)
   - Use generic type T for type-safe return

3. **writeJson(filePath, data)**: Write data as JSON atomically
   - Stringify with JSON.stringify(data, null, 2)
   - Use atomicWrite internally

4. **ensureDir(dirPath)**: Create directory recursively
   - Use fs.promises.mkdir with { recursive: true }

5. **fileExists(filePath)**: Check if file exists
   - Use fs.promises.access with fs.constants.F_OK
   - Return true if exists, false otherwise (no throw on ENOENT)

6. **readFile(filePath)**: Read file content as string
   - Use fs.promises.readFile with 'utf-8' encoding
   - Re-throw errors

All functions must be async and use fs/promises API. Add JSDoc comments for each export.
DO NOT use any sync fs methods (fs.readFileSync, fs.writeFileSync, fs.existsSync, fs.mkdirSync).
  </action>
  <verify>
grep -E "export (async )?function" src/services/FileService.ts | wc -l outputs 6
grep -v "fs.promises" src/services/FileService.ts | grep "fs\." | wc -l outputs 0
  </verify>
  <done>
FileService.ts exists with 6 exported async functions using only fs.promises API
  </done>
</task>

<task type="auto">
  <name>Enhance ESLint to ban synchronous fs methods</name>
  <files>eslint.config.mjs</files>
  <action>
Update `eslint.config.mjs` to add a no-restricted-syntax rule that bans synchronous fs methods:

Add to rules object:
```javascript
"no-restricted-syntax": [
    "error",
    {
        "name": "no-sync-fs",
        "selector": "CallExpression[callee.object.name='fs'][callee.property.name=/^(readFileSync|writeFileSync|existsSync|mkdirSync|readdirSync|unlinkSync|rmdirSync)$/]",
        "message": "Use fs/promises async methods instead of synchronous fs methods. Import from 'fs/promises' and use async/await."
    }
]
```

This rule will catch any usage of:
- fs.readFileSync
- fs.writeFileSync
- fs.existsSync
- fs.mkdirSync
- fs.readdirSync
- fs.unlinkSync
- fs.rmdirSync

DO NOT ban fs methods in test files - tests may legitimately use sync methods for setup.
Keep existing rules intact.
  </action>
  <verify>
grep -A 10 "no-restricted-syntax" eslint.config.mjs | grep "fsSync" outputs > 0
npm run lint 2>&1 | head -20 shows existing lint issues (if any)
  </verify>
  <done>
ESLint config updated with no-restricted-syntax rule banning sync fs methods
  </done>
</task>

</tasks>

<verification>
1. FileService.ts exists and exports 6 functions
2. All FileService functions use fs/promises (no sync methods)
3. ESLint rule bans sync fs methods
4. `npm run compile` passes (TypeScript compilation)
5. `npm run lint` shows expected sync fs violations in existing code (proof that rule works)
</verification>

<success_criteria>
1. FileService provides centralized async file I/O operations
2. ESLint prevents new sync fs usage
3. Atomic write pattern established for all file writes
4. Consistent error handling for ENOENT across read operations
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-quality/08-01-SUMMARY.md` with:
- FileService exports created
- ESLint rule added
- Any deviations from plan
- Next steps (migration of existing code)
</output>
