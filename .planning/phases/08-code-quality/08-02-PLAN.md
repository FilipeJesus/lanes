---
phase: 08-code-quality
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/types/mcp.d.ts
  - src/services/McpAdapter.ts
autonomous: true

must_haves:
  truths:
    - "MCP abstraction layer isolates file I/O from tool handlers"
    - "IMcpAdapter interface defines MCP operations contract"
    - "McpAdapter implements interface using FileService pure functions"
    - "MCP SDK types not imported outside mcp/ directory"
  artifacts:
    - path: "src/types/mcp.d.ts"
      provides: "MCP abstraction interfaces"
      exports: ["IMcpAdapter", "PendingSessionConfig", "WorkflowState"]
      min_lines: 30
    - path: "src/services/McpAdapter.ts"
      provides: "MCP adapter implementation"
      exports: ["McpAdapter", "mcpAdapter"]
      min_lines: 100
  key_links:
    - from: "src/mcp/tools.ts"
      to: "src/services/McpAdapter.ts"
      via: "import and use mcpAdapter instead of direct file I/O"
      pattern: "import.*mcpAdapter.*from.*McpAdapter"
    - from: "src/services/McpAdapter.ts"
      to: "src/services/FileService.ts"
      via: "direct import of pure functions (atomicWrite, readJson, fileExists)"
      pattern: "import.*\\{.*atomicWrite.*\\}.*from.*FileService"
---

<objective>
Create MCP abstraction layer to isolate file I/O from MCP tool handlers.

Purpose: Provide a clean interface for MCP operations that hides implementation details, making the codebase more testable and reducing coupling between MCP tools and file system operations.

Output: IMcpAdapter interface, McpAdapter implementation, and singleton instance for use in tools.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-code-quality/08-RESEARCH.md
@.planning/phases/08-code-quality/08-01-SUMMARY.md

# Reference existing MCP patterns
@src/mcp/tools.ts - Current state persistence and pending session handling
@src/workflow/types.ts - WorkflowState type definition
@src/types/extension.d.ts - PendingSessionConfig type definition
@src/services/FileService.ts - Created in 08-01, exports PURE FUNCTIONS (not a class)
</context>

<tasks>

<task type="auto">
  <name>Create MCP abstraction interfaces</name>
  <files>src/types/mcp.d.ts</files>
  <action>
Create `src/types/mcp.d.ts` with the following interface definition:

```typescript
import type { WorkflowState } from '../workflow/types';

/**
 * Configuration for a pending Claude session request.
 * Matches the structure written to pending-session.json files.
 */
export interface PendingSessionConfig {
    /** The base repository path */
    baseRepoPath: string;
    /** The session/branch name */
    sessionName: string;
    /** Optional workflow to start */
    workflow?: string;
    /** Timestamp when request was created */
    timestamp: number;
}

/**
 * Abstraction layer for MCP file-based operations.
 * Isolates MCP tool handlers from direct file system access.
 */
export interface IMcpAdapter {
    /**
     * Save workflow state to a worktree atomically.
     * @param worktreePath - The worktree root path
     * @param state - The workflow state to persist
     */
    saveState(worktreePath: string, state: WorkflowState): Promise<void>;

    /**
     * Load workflow state from a worktree.
     * @param worktreePath - The worktree root path
     * @returns The workflow state, or null if not found
     */
    loadState(worktreePath: string): Promise<WorkflowState | null>;

    /**
     * Create a pending session request file.
     * @param config - The pending session configuration
     */
    createPendingSession(config: PendingSessionConfig): Promise<void>;

    /**
     * Create a clear request file for a session.
     * @param worktreePath - The worktree root path
     */
    createClearRequest(worktreePath: string): Promise<void>;

    /**
     * Check if a workflow state file exists.
     * @param worktreePath - The worktree root path
     */
    hasState(worktreePath: string): Promise<boolean>;
}
```

Import WorkflowState from ../workflow/types (re-export existing type).
DO NOT import from @modelcontextprotocol/sdk - this is a clean abstraction.
  </action>
  <verify>
grep -c "export interface" src/types/mcp.d.ts outputs 2
grep "IMcpAdapter" src/types/mcp.d.ts | grep -c "export" outputs 1
  </verify>
  <done>
mcp.d.ts exists with IMcpAdapter and PendingSessionConfig interfaces
  </done>
</task>

<task type="auto">
  <name>Create McpAdapter implementation using FileService pure functions</name>
  <files>src/services/McpAdapter.ts</files>
  <action>
Create `src/services/McpAdapter.ts` with:

**IMPORTANT:** FileService exports PURE FUNCTIONS (not a class). The exports are:
`atomicWrite`, `readJson`, `writeJson`, `ensureDir`, `fileExists`, `readFile`.
McpAdapter must import these functions directly and call them as standalone functions.
There is NO FileService class and NO constructor injection needed.

1. **Imports at top of file:**
   ```typescript
   import * as path from 'path';
   import { atomicWrite, readJson, fileExists } from './FileService';
   import type { IMcpAdapter, PendingSessionConfig } from '../types/mcp';
   import type { WorkflowState } from '../workflow/types';
   ```

2. **McpAdapter class** implementing IMcpAdapter
   - Constructor takes NO arguments (no dependency injection needed)
   - Private helper methods for path generation:
     - `getStatePath(worktreePath)` -> returns `path.join(worktreePath, 'workflow-state.json')`
     - `getPendingSessionPath(baseRepoPath, sessionName)` -> returns `path.join(baseRepoPath, '.git', '.lanes', \`pending-${sessionName}.json\`)`
     - `getClearRequestPath(worktreePath)` -> returns `path.join(worktreePath, '.clear-request')`

3. **IMcpAdapter method implementations** (call FileService functions directly):
   - `saveState(worktreePath, state)`: Call `atomicWrite(this.getStatePath(worktreePath), JSON.stringify(state, null, 2))`
   - `loadState(worktreePath)`: Call `readJson<WorkflowState>(this.getStatePath(worktreePath))`
   - `createPendingSession(config)`: Call `atomicWrite(this.getPendingSessionPath(config.baseRepoPath, config.sessionName), JSON.stringify(config, null, 2))`
   - `createClearRequest(worktreePath)`: Call `atomicWrite(this.getClearRequestPath(worktreePath), JSON.stringify({ timestamp: Date.now() }))`
   - `hasState(worktreePath)`: Call `fileExists(this.getStatePath(worktreePath))`

4. **Singleton export** (no constructor args needed):
   ```typescript
   export const mcpAdapter = new McpAdapter();
   ```

Reference existing implementations:
- src/mcp/tools.ts lines 40-69 (saveState, loadState pattern)
- src/services/SessionProcessService.ts (pending session path pattern)

Use path.join for all path construction. No sync fs operations. No direct fs imports.
  </action>
  <verify>
grep -c "class McpAdapter" src/services/McpAdapter.ts outputs 1
grep -c "implements IMcpAdapter" src/services/McpAdapter.ts outputs 1
grep "export.*mcpAdapter" src/services/McpAdapter.ts outputs > 0
grep "import.*atomicWrite.*readJson.*fileExists.*from.*FileService" src/services/McpAdapter.ts outputs > 0
grep -c "constructor()" src/services/McpAdapter.ts outputs 0 (no constructor needed, or empty constructor)
  </verify>
  <done>
McpAdapter class implements IMcpAdapter using FileService pure functions (atomicWrite, readJson, fileExists) called directly - no constructor injection, no class instance dependency
  </done>
</task>

</tasks>

<verification>
1. mcp.d.ts defines IMcpAdapter and PendingSessionConfig interfaces
2. McpAdapter imports FileService pure functions directly: `import { atomicWrite, readJson, fileExists } from './FileService'`
3. McpAdapter methods call FileService functions directly (e.g., `atomicWrite(path, content)` not `this.fileService.atomicWrite(...)`)
4. Singleton mcpAdapter exported with no constructor args: `new McpAdapter()`
5. No direct fs operations in McpAdapter (all via FileService functions)
6. `npm run compile` passes
</verification>

<success_criteria>
1. MCP abstraction layer created with clean interface
2. File I/O isolated behind McpAdapter using FileService pure functions
3. MCP SDK types not imported in adapter (clean abstraction)
4. Ready for migration of existing MCP tools
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-quality/08-02-SUMMARY.md` with:
- Interfaces created
- McpAdapter implementation details
- FileService pure function integration confirmed (not class injection)
- Next steps (migrate tools to use adapter)
</output>
