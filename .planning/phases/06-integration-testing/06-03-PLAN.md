---
phase: 06-integration-testing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/test/integration/git-error-recovery.test.ts
autonomous: true

must_haves:
  truths:
    - "Git merge-base failure triggers diff fallback (three-dot syntax)"
    - "Network timeout on fetch is handled gracefully"
    - "Worktree conflict errors are recoverable with prune"
    - "Invalid branch errors provide actionable user messages"
    - "System remains consistent after git error recovery"
  artifacts:
    - path: "src/test/integration/git-error-recovery.test.ts"
      provides: "Integration tests for git error recovery and fallback behaviors"
      min_lines: 180
  key_links:
    - from: "src/test/integration/git-error-recovery.test.ts"
      to: "src/gitService.ts"
      via: "sinon.stub() on execGit"
      pattern: "sinon.stub.*execGit"
    - from: "src/test/integration/git-error-recovery.test.ts"
      to: "src/utils.ts"
      via: "validateBranchName function"
      pattern: "validateBranchName"
</key_links>
---

<objective>
Create git error recovery integration tests that verify graceful failure handling and fallback behaviors for common git operation failures.

Purpose: Git operations can fail for various reasons (network, invalid refs, merge-base failures). Integration tests ensure the extension handles these errors gracefully with appropriate fallbacks and recovery mechanisms.

Output: New `src/test/integration/git-error-recovery.test.ts` with comprehensive git error recovery tests.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-integration-testing/06-RESEARCH.md
@.planning/codebase/TESTING.md
@src/test/testSetup.ts

# Prior phases with relevant patterns
@.planning/phases/01-critical-bug-fixes/01-01-PLAN.md
@.planning/phases/02-error-handling/02-01-PLAN.md
@.planning/phases/05-test-foundation/05-01-PLAN.md

# Source files to test
@src/gitService.ts
@src/utils.ts
@src/extension.ts
@src/errors/GitError.ts
</context>

<tasks>

<task type="auto">
  <name>Create git-error-recovery.test.ts with fallback and recovery tests</name>
  <files>src/test/integration/git-error-recovery.test.ts</files>
  <action>
Create `src/test/integration/git-error-recovery.test.ts` with the following test structure:

**File structure:**
1. Import statements:
   - `assert` from node:assert
   - `sinon` from sinon
   - `{ vol }` from memfs
   - `{ GitError }` from ../../errors
   - `{ execGit }` from ../../gitService
   - `{ validateBranchName }` from ../../utils
   - `{ setupMemfs, setupGitStubs, createTestRepo }` from ../testSetup

2. Suite: "Git Error Recovery: Merge-base Fallback"
   - setup(): Initialize memfs and gitStubs
   - teardown(): Reset memfs and restore stubs

   Test: "should fall back to diff when merge-base fails"
     * Stub execGit to reject merge-base with "not a valid commit" error
     * Stub execGit to resolve diff with three-dot syntax (A...B)
     * Call git function that uses merge-base (diff command)
     * Verify diff fallback was attempted
     * Assert success despite merge-base failure

   Test: "should handle merge-base timeout gracefully"
     * Stub execGit to reject merge-base with timeout error
     * Verify error is GitError with timeout context
     * Assert userMessage mentions timeout

3. Suite: "Git Error Recovery: Worktree Conflicts"
   Test: "should prune and retry on worktree add conflict"
     * Stub first worktree add to fail with "already exists" error
     * Stub worktree prune to succeed
     * Stub second worktree add to succeed
     * Call function that creates worktree with retry
     * Verify prune was called between attempts
     * Assert success after recovery

   Test: "should give up after max retries on persistent worktree error"
     * Stub worktree add to always fail with same error
     * Stub worktree prune to succeed
     * Call function with max retry limit
     * Assert failure after exhausting retries
     * Verify error includes retry context

4. Suite: "Git Error Recovery: Network Errors"
   Test: "should handle fetch timeout with informative error"
     * Stub fetch to reject with connection timeout
     * Call fetch function
     * Verify GitError with timeout details
     * Assert userMessage suggests checking network

   Test: "should handle remote not found error"
     * Stub ls-remote to fail with "remote not found"
     * Verify GitError with remote context
     * Assert userMessage mentions checking remote name

5. Suite: "Git Error Recovery: Invalid References"
   Test: "should provide actionable error for invalid branch"
     * Stub branch validation to reject @{ sequence
     * Call function that uses the branch
     * Verify ValidationError thrown before git operations
     * Assert no git commands executed (stub not called)
     * Verify userMessage explains @{ restriction

   Test: "should handle non-existent ref gracefully"
     * Stub show-ref to fail with "not a valid ref"
     * Verify GitError with ref details
     * Assert userMessage suggests checking branch name

6. Suite: "Git Error Recovery: State Consistency"
   Test: "should leave consistent state after failed worktree creation"
     * Setup: Create virtual repo structure
     * Stub worktree add to fail after partial creation
     * Attempt worktree creation
     * Verify cleanup happened (no orphaned files)
     * Assert extension state remains consistent

   Test: "should not corrupt session list after git error"
     * Setup: Create existing session list
     * Stub git operation to fail
     * Attempt to add new session
     * Verify original session list intact
     * Assert new session not added

**Key patterns from Phase 5:**
- Use `setupGitStubs().execGit` to mock gitService.execGit
- Use stub chaining: `.onFirstCall().rejects()`, `.onSecondCall().resolves()`
- Use `sinon.assert.calledWith()` to verify specific git commands
- Use `sinon.assert.callCount()` to verify retry behavior
- Each test: Arrange (stub git), Act (call function), Assert (verify behavior + state)

**Error simulation patterns:**
- Merge-base failure: `rejects(new Error('fatal: not a valid commit'))`
- Worktree conflict: `rejects(new Error('fatal: worktree already exists'))`
- Network timeout: `rejects(new Error('connection timeout'))`
- Invalid ref: `rejects(new Error('fatal: invalid branch name'))`
  </action>
  <verify>Run `npm test -- --grep "Git Error Recovery"` to verify new tests pass</verify>
  <done>All git error recovery integration tests pass, covering:
1. Merge-base fallback to diff command
2. Worktree conflict recovery with prune
3. Network error handling (timeout, remote not found)
4. Invalid reference errors with actionable messages
5. State consistency after failed operations</done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:
```bash
npm test
```

Verify new tests are included in test output:
```bash
npm test -- --grep "Git Error Recovery"
```

Check specific error scenarios:
```bash
npm test -- --grep "merge-base"
npm test -- --grep "worktree.*conflict"
```
</verification>

<success_criteria>
1. `git-error-recovery.test.ts` contains at least 7 test cases
2. Tests verify both error detection AND recovery mechanisms
3. Tests check state consistency after errors (no orphaned state)
4. All tests use sinon stubs for isolation (no real git)
5. Full test suite passes (`npm test`)
</success_criteria>

<output>
After completion, create `.planning/phases/06-integration-testing/06-03-SUMMARY.md` with:
- Test cases implemented
- Error scenarios covered
- Any missing recovery paths identified
- Recommendations for production error handling
</output>
