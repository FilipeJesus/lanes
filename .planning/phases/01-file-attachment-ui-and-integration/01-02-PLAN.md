---
phase: 01-file-attachment-ui-and-integration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/SessionService.ts
  - src/extension.ts
  - src/commands/sessionCommands.ts
  - src/test/session/session-form.test.ts
autonomous: true

must_haves:
  truths:
    - "When session is created with attachments, the starting prompt includes a formatted list of absolute file paths BEFORE the user's typed text"
    - "When session is created without attachments, the prompt is sent as-is with no empty attachment section"
    - "When user attaches files but types no prompt, only the file list is sent"
    - "All existing tests continue to pass"
    - "New tests verify attachment callback, prompt assembly, and form HTML"
  artifacts:
    - path: "src/services/SessionService.ts"
      provides: "Prompt assembly with attachment paths"
      contains: "assembleStartingPrompt"
    - path: "src/extension.ts"
      provides: "Updated callback wiring passing attachments from form to createSession"
      contains: "attachments"
    - path: "src/commands/sessionCommands.ts"
      provides: "Updated command registration (if needed)"
      contains: "createSession"
    - path: "src/test/session/session-form.test.ts"
      provides: "Tests for attachment UI, callback, and state persistence"
      contains: "attachment"
  key_links:
    - from: "src/extension.ts (setOnSubmit callback)"
      to: "src/services/SessionService.ts (createSession)"
      via: "passes attachments parameter through"
      pattern: "attachments"
    - from: "src/services/SessionService.ts (createSession)"
      to: "src/services/TerminalService.ts (openClaudeTerminal)"
      via: "assembled prompt with attachment paths"
      pattern: "assembleStartingPrompt"
---

<objective>
Wire the attachment file paths from the form through to the terminal prompt: add prompt assembly logic that formats attached file paths into the starting prompt, update the callback chain from form -> extension -> SessionService, and add comprehensive tests.

Purpose: This completes the data flow -- attachments selected in Plan 01's UI are now formatted into the prompt that Claude receives when the session starts.
Output: Working end-to-end attachment feature, all tests passing.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-file-attachment-ui-and-integration/01-CONTEXT.md
@.planning/phases/01-file-attachment-ui-and-integration/01-RESEARCH.md
@.planning/phases/01-file-attachment-ui-and-integration/01-01-SUMMARY.md

@src/SessionFormProvider.ts
@src/services/SessionService.ts
@src/services/TerminalService.ts
@src/extension.ts
@src/commands/sessionCommands.ts
@src/test/session/session-form.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prompt assembly and update callback chain for attachments</name>
  <files>src/services/SessionService.ts, src/extension.ts, src/commands/sessionCommands.ts</files>
  <action>
**1. Add `assembleStartingPrompt` function to `src/services/SessionService.ts`:**

Add this function before the `createSession` function (around line ~130):
```typescript
/**
 * Assemble the starting prompt with optional file attachments.
 * Attachments are listed BEFORE the user's typed text.
 * Format:
 *   Attached files:
 *   - /absolute/path/to/file1.ts
 *   - /absolute/path/to/file2.ts
 *
 *   [user's typed prompt text]
 */
function assembleStartingPrompt(userPrompt: string, attachments: string[]): string {
    let prompt = '';

    if (attachments.length > 0) {
        prompt += 'Attached files:\n';
        for (const filePath of attachments) {
            // Skip paths with control characters (newlines, nulls)
            if (/[\n\r\0]/.test(filePath)) {
                console.warn(`Lanes: Skipping invalid file path in attachment`);
                continue;
            }
            prompt += `- ${filePath}\n`;
        }
        prompt += '\n';
    }

    const trimmedUserPrompt = userPrompt.trim();
    if (trimmedUserPrompt) {
        prompt += trimmedUserPrompt;
    }

    return prompt;
}
```

**2. Update `createSession` function signature in `src/services/SessionService.ts`:**

Add `attachments: string[]` parameter after `workflow`:
```typescript
async function createSession(
    name: string,
    prompt: string,
    permissionMode: PermissionMode,
    sourceBranch: string,
    workflow: string | null,
    attachments: string[],    // NEW PARAMETER
    workspaceRoot: string | undefined,
    sessionProvider: ClaudeSessionProvider,
    codeAgent?: CodeAgent
): Promise<void> {
```

**3. Use `assembleStartingPrompt` in `createSession`:**

Inside the `createSession` function, right before the `openClaudeTerminalImpl` call (around line ~425-426), assemble the prompt:
```typescript
// Assemble prompt with attachment paths
const assembledPrompt = assembleStartingPrompt(prompt, attachments);
```

Then pass `assembledPrompt` instead of `prompt` to `openClaudeTerminalImpl`:
```typescript
await openClaudeTerminalImpl(trimmedName, worktreePath, assembledPrompt, permissionMode, workflow, codeAgent, workspaceRoot);
```

**4. Update the callback in `src/extension.ts` (line ~155-158):**

The `setOnSubmit` callback needs to accept and forward the `attachments` parameter:
```typescript
sessionFormProvider.setOnSubmit(async (name: string, prompt: string, sourceBranch: string, permissionMode: PermissionMode, workflow: string | null, attachments: string[]) => {
    await createSession(name, prompt, permissionMode, sourceBranch, workflow, attachments, baseRepoPath, sessionProvider, codeAgent);
});
```

**5. Update the command palette `createSession` call in `src/commands/sessionCommands.ts` (line ~140):**

The `createSession` call from the command palette doesn't have attachments, so pass an empty array:
```typescript
await createSession(name, '', 'acceptEdits', '', null, [], baseRepoPath, sessionProvider, codeAgent);
```

**Important notes:**
- The prompt format is per user decision: attachments BEFORE user text, with "Attached files:" header
- If no attachments and no prompt, `assembleStartingPrompt` returns empty string (no empty section)
- If attachments but no prompt, only the file list is sent (no default instruction added) per user decision
- File paths with control characters are skipped silently (defensive coding per research pitfall #6)
- The `assembleStartingPrompt` function is NOT exported -- it's internal to SessionService
  </action>
  <verify>
Run `npm run compile` -- should succeed with no TypeScript errors now that all call sites match the updated `SessionFormSubmitCallback` type.
  </verify>
  <done>
The `createSession` function accepts attachments, assembles them into the prompt using the locked format ("Attached files:\n- /path\n\n[user text]"), and all call sites are updated. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for attachment UI, callback, prompt assembly, and state persistence</name>
  <files>src/test/session/session-form.test.ts</files>
  <action>
Update `src/test/session/session-form.test.ts` to add tests covering the attachment feature. Add a new test suite `'File Attachments'` within the existing `suite('Session Form', ...)`.

**Test Suite: File Attachment UI**

```typescript
suite('File Attachment UI', () => {
    test('Form has attach button inside textarea wrapper', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes('id="attachBtn"'), 'Form should have attach button');
        assert.ok(html.includes('class="attach-btn"'), 'Attach button should have correct class');
        assert.ok(html.includes('title="Attach files"'), 'Attach button should have tooltip');
        assert.ok(html.includes('aria-label="Attach files"'), 'Attach button should have aria-label');
        assert.ok(html.includes('class="textarea-wrapper"'), 'Textarea should be wrapped in textarea-wrapper');
    });

    test('Form has attachment chips container', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes('id="attachmentChips"'), 'Form should have attachment chips container');
        assert.ok(html.includes('class="attachment-chips"'), 'Chips container should have correct class');
    });

    test('Form JavaScript handles showFilePicker message', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes("command: 'showFilePicker'"), 'Should send showFilePicker message on button click');
    });

    test('Form JavaScript handles filesSelected message', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes("case 'filesSelected'"), 'Should handle filesSelected message');
    });

    test('Form JavaScript includes duplicate detection', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes('.toLowerCase()'), 'Should use case-insensitive comparison for duplicates');
    });

    test('Form JavaScript includes file limit check', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes('MAX_FILES'), 'Should have MAX_FILES constant');
        assert.ok(html.includes('attachments.length >= MAX_FILES'), 'Should check file limit before opening picker');
    });
});
```

**Test Suite: File Attachment Callback**

```typescript
suite('File Attachment Callback', () => {
    test('Session form passes attachments to callback', async () => {
        let receivedAttachments: string[] = [];
        let callbackInvoked = false;

        const callback: SessionFormSubmitCallback = (
            _name, _prompt, _sourceBranch, _permissionMode, _workflow, attachments
        ) => {
            callbackInvoked = true;
            receivedAttachments = attachments;
        };

        provider.setOnSubmit(callback);

        const mockView = new MockWebviewView();
        provider.resolveWebviewView(
            mockView as unknown as vscode.WebviewView,
            {} as vscode.WebviewViewResolveContext,
            { isCancellationRequested: false, onCancellationRequested: () => ({ dispose: () => {} }) } as vscode.CancellationToken
        );

        mockView.webview.simulateMessage({
            command: 'createSession',
            name: 'test-session',
            prompt: 'Test prompt',
            sourceBranch: '',
            permissionMode: 'acceptEdits',
            workflow: null,
            attachments: ['/path/to/file1.ts', '/path/to/file2.ts']
        });

        await new Promise(resolve => setTimeout(resolve, 10));

        assert.ok(callbackInvoked, 'Callback should have been invoked');
        assert.deepStrictEqual(receivedAttachments, ['/path/to/file1.ts', '/path/to/file2.ts']);
    });

    test('Session form passes empty attachments when none selected', async () => {
        let receivedAttachments: string[] = ['should-be-empty'];

        const callback: SessionFormSubmitCallback = (
            _name, _prompt, _sourceBranch, _permissionMode, _workflow, attachments
        ) => {
            receivedAttachments = attachments;
        };

        provider.setOnSubmit(callback);

        const mockView = new MockWebviewView();
        provider.resolveWebviewView(
            mockView as unknown as vscode.WebviewView,
            {} as vscode.WebviewViewResolveContext,
            { isCancellationRequested: false, onCancellationRequested: () => ({ dispose: () => {} }) } as vscode.CancellationToken
        );

        mockView.webview.simulateMessage({
            command: 'createSession',
            name: 'test-session',
            prompt: '',
            sourceBranch: '',
            permissionMode: 'acceptEdits',
            workflow: null
            // No attachments field
        });

        await new Promise(resolve => setTimeout(resolve, 10));

        assert.deepStrictEqual(receivedAttachments, [], 'Missing attachments should default to empty array');
    });

    test('SessionFormSubmitCallback type includes attachments parameter', () => {
        // Compile-time type check
        const callback: SessionFormSubmitCallback = (
            name: string,
            prompt: string,
            sourceBranch: string,
            permissionMode: PermissionMode,
            workflow: string | null,
            attachments: string[]
        ) => {
            assert.ok(Array.isArray(attachments));
        };

        provider.setOnSubmit(callback);
        assert.ok(true, 'Callback with attachments parameter was accepted');
    });
});
```

**Test Suite: File Attachment State Persistence**

```typescript
suite('File Attachment State Persistence', () => {
    test('Form JavaScript saves attachments in state', () => {
        const html = getFormHtml(provider);
        assert.ok(html.includes('attachments: attachments'), 'saveState should include attachments');
    });

    test('Form JavaScript restores attachments from state', () => {
        const html = getFormHtml(provider);
        assert.ok(
            html.includes('previousState.attachments'),
            'State restoration should check for attachments'
        );
    });

    test('Form submission includes attachments array', () => {
        const html = getFormHtml(provider);
        assert.ok(
            html.includes('attachments: attachments.map'),
            'Form submission should include attachments paths'
        );
    });
});
```

**Update existing callback tests:**

The existing `'Workflow Callback'` tests need to be updated because `SessionFormSubmitCallback` now has 6 parameters instead of 5. Update each callback in the existing tests to accept the `attachments` parameter (even if they don't assert on it). For example, in "Session form passes workflow to callback":
```typescript
const callback: SessionFormSubmitCallback = (
    name: string,
    prompt: string,
    sourceBranch: string,
    permissionMode: PermissionMode,
    workflow: string | null,
    attachments: string[]    // ADD THIS
) => {
    callbackInvoked = true;
    receivedWorkflow = workflow;
};
```

Apply this pattern to ALL existing callbacks in the test file that use `SessionFormSubmitCallback`.
  </action>
  <verify>
Run `npm test` from the project root. All existing tests should pass AND the new attachment tests should pass. Expected: 0 failures.
  </verify>
  <done>
Test suite includes tests for: attachment button presence in HTML, chips container, showFilePicker/filesSelected message handling, duplicate detection logic, file limit enforcement, callback receiving attachments, default empty array for missing attachments, state persistence of attachments, and form submission including attachment paths. All tests pass. Existing tests updated for new callback signature.
  </done>
</task>

</tasks>

<verification>
- `npm run compile` succeeds with zero errors
- `npm test` passes all existing tests AND new attachment tests
- Creating a session with attachments results in a prompt that starts with "Attached files:\n- /path/...\n\n[user text]"
- Creating a session without attachments sends the prompt as-is (no empty attachment section)
- Creating a session with attachments but no typed prompt sends just the file list
</verification>

<success_criteria>
- `assembleStartingPrompt` correctly formats attachments before user text
- Empty attachments produce no attachment section in the prompt
- All callback chain updated: form -> extension.ts -> SessionService.createSession
- Command palette createSession passes empty attachments array
- All existing tests pass with updated callback signatures
- New tests cover attachment UI elements, callback, state persistence
- `npm test` passes with 0 failures
</success_criteria>

<output>
After completion, create `.planning/phases/01-file-attachment-ui-and-integration/01-02-SUMMARY.md`
</output>
