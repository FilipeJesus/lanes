---
phase: 02-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/errors/LanesError.ts
  - src/errors/GitError.ts
  - src/errors/ValidationError.ts
  - src/errors/index.ts
  - src/gitService.ts
  - src/extension.ts
  - src/test/errorHandling.test.ts
autonomous: true

must_haves:
  truths:
    - "User sees descriptive error messages when operations fail (not 'Error: failed')"
    - "All critical functions have tests covering error paths"
    - "Error types are consistent across codebase (no mixed null/throw patterns)"
  artifacts:
    - path: "src/errors/LanesError.ts"
      provides: "Base error class for all Lanes errors"
      exports: ["LanesError"]
    - path: "src/errors/GitError.ts"
      provides: "Git operation failure errors"
      exports: ["GitError"]
    - path: "src/errors/ValidationError.ts"
      provides: "User input validation errors"
      exports: ["ValidationError"]
    - path: "src/errors/index.ts"
      provides: "Error exports barrel file"
      exports: ["LanesError", "GitError", "ValidationError"]
    - path: "src/test/errorHandling.test.ts"
      provides: "Error path test coverage"
      contains: "GitError"
  key_links:
    - from: "src/gitService.ts"
      to: "src/errors/GitError.ts"
      via: "import and throw on failure"
      pattern: "throw new GitError"
    - from: "src/extension.ts"
      to: "src/errors/index.ts"
      via: "import and catch for user display"
      pattern: "catch.*error.*instanceof LanesError"
---

<objective>
Create a unified error handling system with custom error types that provide clear, actionable error messages to users.

This plan addresses REL-04 (null returns replaced with proper error types), REL-06 (user sees clear error messages), and TEST-01 (error path coverage).

**Purpose:** Users currently receive generic "Error: failed" messages without context. Operations fail silently or return null without explanation. This plan introduces a typed error hierarchy that:

1. Provides descriptive error messages for each failure type
2. Preserves stack traces for debugging
3. Enables type-safe error handling with discriminated unions
4. Follows the existing WorkflowValidationError pattern (proven to work)

**Output:**
- `src/errors/` directory with LanesError hierarchy
- Updated `gitService.ts` to throw GitError
- Updated `extension.ts` to surface error messages via VS Code API
- New test file covering error paths
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-error-handling/02-RESEARCH.md
@.planning/ROADMAP.md
@.planning/PROJECT.md

@src/workflow/loader.ts (reference for WorkflowValidationError pattern)
@src/utils.ts (reference for ValidationResult pattern)
@src/gitService.ts (to update with GitError)
@src/extension.ts (to update error handling)
</context>

<tasks>

<task type="auto">
  <name>Create error type hierarchy</name>
  <files>src/errors/LanesError.ts, src/errors/GitError.ts, src/errors/ValidationError.ts, src/errors/index.ts</files>
  <action>
    Create the error type hierarchy following the WorkflowValidationError pattern (see src/workflow/loader.ts lines 10-17):

    **src/errors/LanesError.ts:**
    - Abstract base class extending Error
    - Abstract `kind` property: 'git' | 'validation' | 'filesystem' | 'config'
    - Note: 'filesystem' and 'config' kinds reserved for future phases (Phase 3, Phase 4)
    - `userMessage` property for VS Code display (defaults to message)
    - Proper Error inheritance (sets this.name, calls super)

    **src/errors/GitError.ts:**
    - Extends LanesError
    - kind = 'git' (discriminator for type narrowing)
    - Properties: command (string[]), exitCode (number | undefined)
    - Constructor: command, exitCode, cause
    - userMessage: "Git operation failed. {exitCode ? `Exit code: ${exitCode}. ` : ''}{command details}"
    - DO NOT include sensitive data in userMessage

    **src/errors/ValidationError.ts:**
    - Extends LanesError
    - kind = 'validation'
    - Properties: field (string), value (string)
    - Constructor: field, value, reason
    - userMessage: "Invalid {field}: "{value}". {reason}"

    **src/errors/index.ts:**
    - Re-export all error types

    Follow the existing WorkflowValidationError pattern exactly for consistency.
  </action>
  <verify>
    grep -r "class.*Error" src/errors/ | wc -l | xargs -I {} test {} -eq 3
    npm run compile  # TypeScript should pass
  </verify>
  <done>
    Error types compile and export correctly from index.ts
  </done>
</task>

<task type="auto">
  <name>Update gitService.ts to throw GitError</name>
  <files>src/gitService.ts</files>
  <action>
    Replace generic Error throws in execGit with GitError:

    1. Import GitError from './errors'
    2. In the 'close' event handler (line ~94), replace:
       ```typescript
       reject(new Error(stderr || `Git command failed with code ${code}`));
       ```
       With:
       ```typescript
       reject(new GitError(args, code, stderr || `Git command failed with code ${code}`));
       ```
    3. In the 'error' event handler (line ~90), replace:
       ```typescript
       reject(new Error(`Failed to spawn git process: ${err.message}`));
       ```
       With:
       ```typescript
       reject(new GitError(args, undefined, `Failed to spawn git process: ${err.message}`));
       ```
    4. Update JSDoc to reflect GitError usage

    DO NOT change the function signature - still returns Promise<string> on success, throws on failure.
  </action>
  <verify>
    grep "new Error(" src/gitService.ts | wc -l | xargs -I {} test {} -eq 0
    grep "new GitError(" src/gitService.ts | wc -l | xargs -I {} test {} -ge 2
    npm run compile
  </verify>
  <done>
    gitService.ts throws GitError instead of generic Error
  </done>
</task>

<task type="auto">
  <name>Update extension.ts error handling</name>
  <files>src/extension.ts</files>
  <action>
    Update error handling in command handlers to surface user-friendly messages:

    1. Add import at top: `import { LanesError, GitError, ValidationError } from './errors';`

    2. Update createSession function (around line ~1966-1970) to handle LanesError types:
       - After catch (err), check instanceof before showing message
       - Extract userMessage from LanesError subtypes
       - Pattern:
         ```typescript
         } catch (err) {
             console.error(err);
             let userMessage = 'Failed to create session.';
             if (err instanceof GitError) {
                 userMessage = err.userMessage;
             } else if (err instanceof ValidationError) {
                 userMessage = err.userMessage;
             } else if (err instanceof LanesError) {
                 userMessage = err.userMessage;
             } else {
                 // Generic fallback
                 userMessage = `Git Error: ${getErrorMessage(err)}`;
             }
             vscode.window.showErrorMessage(userMessage);
             throw err;
         }
         ```

    3. Apply same pattern to other critical command handlers:
       - deleteSession (around line 1138)
       - showGitChanges (around line 1378)
       - createWorkflow (around line 2922)
       - clearSession (around line 1611)

    4. DO NOT change error throwing behavior - only improve message display
  </action>
  <verify>
    grep "instanceof.*Error" src/extension.ts | wc -l | xargs -I {} test {} -ge 5
    npm run compile
  </verify>
  <done>
    Command handlers show userMessage from LanesError types
  </done>
</task>

<task type="auto">
  <name>Add error path tests</name>
  <files>src/test/errorHandling.test.ts</files>
  <action>
    Create test file for error path coverage following existing test patterns (see src/test/extension.test.ts):

    **src/test/errorHandling.test.ts:**

    Suite: 'Error Handling'

    Test 1: "GitError includes command and exit code"
    - Create GitError with command=['worktree', 'add'], exitCode=128
    - Verify kind === 'git'
    - Verify command property is set
    - Verify exitCode property is set
    - Verify userMessage contains "Exit code: 128"

    Test 2: "ValidationError includes field and value"
    - Create ValidationError with field='branchName', value='../../etc/passwd', reason='path traversal not allowed'
    - Verify kind === 'validation'
    - Verify userMessage contains "Invalid branchName"

    Test 3: "LanesError discriminator works for type narrowing"
    - Create array of mixed errors
    - Use instanceof checks with kind discriminator
    - Verify TypeScript can narrow types

    Test 4: "GitError thrown from execGit is catchable"
    - Mock execGit to reject with GitError
    - Verify error is caught correctly
    - Verify instanceof GitError returns true

    Follow existing test setup/teardown patterns from extension.test.ts (lines 30-53).
  </action>
  <verify>
    npm test -- src/test/errorHandling.test.ts
  </verify>
  <done>
    All error path tests pass (4 tests minimum)
  </done>
</task>

</tasks>

<verification>
1. **Error types exist and compile**: `npm run compile` passes with no errors
2. **GitError is used in gitService.ts**: `grep "new GitError(" src/gitService.ts` returns 2+ matches
3. **User messages are surfaced**: `grep "userMessage" src/extension.ts` returns 5+ matches
4. **Tests cover error paths**: `npm test -- src/test/errorHandling.test.ts` passes all tests
5. **No mixed patterns**: Verify no functions return `{success: boolean, error?: string}` for operations that should throw (except ValidationResult which is intentional)
</verification>

<success_criteria>
1. Running `npm test` shows all new error tests passing
2. Opening VS Code output shows no TypeScript compilation errors
3. Creating a session with invalid input shows ValidationError.userMessage in the error dialog
4. Git operation failures show GitError.userMessage with command context
5. Code review shows consistent instanceof checks for error handling
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-01-SUMMARY.md` with:
- Files created/modified
- Tests added and their coverage
- Any decisions made during implementation
- Next steps for remaining Phase 2 work (if any)
</output>
