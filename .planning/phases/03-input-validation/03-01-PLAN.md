---
phase: 03-input-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/validation/index.ts
  - src/validation/validators.ts
  - src/validation/schemas.ts
  - src/validation/pathSanitizer.ts
  - src/extension.ts
  - src/ClaudeSessionProvider.ts
  - src/test/validation.test.ts
autonomous: true

must_haves:
  truths:
    - "User cannot create sessions with malicious names containing path traversal (../)"
    - "Invalid configuration values are rejected with clear ValidationError messages"
    - "All user-facing inputs (session names, branches, config) pass through validation before use"
  artifacts:
    - path: "src/validation/index.ts"
      provides: "Barrel export for validation module"
      exports: ["validateSessionName", "validateRelativePath", "validateConfigString", "safeResolve"]
    - path: "src/validation/validators.ts"
      provides: "Core validator functions using ValidationResult pattern"
      contains: "validateSessionName"
    - path: "src/validation/schemas.ts"
      provides: "Configuration value validators for all lanes.* settings"
      contains: "validateWorktreesFolder", "validatePromptsFolder", "validateLocalSettingsPropagation"
    - path: "src/validation/pathSanitizer.ts"
      provides: "Path security utilities for safe path resolution"
      contains: "safeResolve"
    - path: "src/test/validation.test.ts"
      provides: "Test coverage for path traversal scenarios and config validation"
      contains: "path traversal tests"
  key_links:
    - from: "src/extension.ts"
      to: "src/validation/validators.ts"
      via: "import validateSessionName"
      pattern: "validateSessionName\\(message\\.name\\)"
    - from: "src/ClaudeSessionProvider.ts"
      to: "src/validation/schemas.ts"
      via: "config value validation"
      pattern: "validateWorktreesFolder\\(\\)|validatePromptsFolder\\(\\)"
---

<objective>
Create centralized validation module with composable validators for session names and configuration values, enforcing security boundaries before user input reaches file system operations.

Purpose: Prevent path traversal attacks and invalid configuration from compromising security or stability. Centralized validation ensures consistent error handling and reduces duplication.

Output: src/validation/ module with validators, path sanitizers, and comprehensive security tests.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-input-validation/03-RESEARCH.md
@.planning/phases/02-error-handling/02-01-SUMMARY.md

# Existing patterns to follow
@src/utils.ts - ValidationResult interface, validateBranchName pattern
@src/errors/ValidationError.ts - Phase 2 ValidationError class
@src/SessionFormProvider.ts - Type guard pattern (isValidPermissionMode)
@src/ClaudeSessionProvider.ts - Existing getWorktreesFolder() security checks
</context>

<tasks>

<task type="auto">
  <name>Create validation module structure with validators.ts</name>
  <files>src/validation/validators.ts</files>
  <action>
Create src/validation/validators.ts with session name validation:

1. Import ValidationResult from src/utils.ts (existing pattern)
2. Import ValidationError from src/errors (Phase 2 pattern)
3. Export validateSessionName(name: string): ValidationResult
   - Check empty/whitespace-only: reject with error
   - Check for '..' sequences: REJECT (path traversal)
   - Check for null bytes (\x00): REJECT
   - Check for excessive length (>200 chars): REJECT
   - Return {valid: true} if all checks pass

4. Export validateRelativePath(path: string, options): ValidationResult
   - Check empty: reject
   - Reject '..' unless allowTraversal=true
   - Reject absolute paths unless allowAbsolute=true
   - Use path.isAbsolute() for cross-platform check

Follow the exact ValidationResult pattern from utils.ts lines 11-14.
Use clear error messages that mention the specific issue.
  </action>
  <verify>npm run compile passes with no TypeScript errors</verify>
  <done>validateSessionName rejects '../etc/passwd', '', '\x00', and names >200 chars; validateRelativePath prevents path traversal by default</done>
</task>

<task type="auto">
  <name>Create configuration schema validators (schemas.ts)</name>
  <files>src/validation/schemas.ts</files>
  <action>
Create src/validation/schemas.ts with runtime config validators:

1. Export validateWorktreesFolder(value: unknown): ValidationResult
   - Check typeof === 'string'
   - Check trim() !== value (no whitespace padding)
   - Check for '..' sequences: REJECT
   - Check for invalid Windows chars: /[<>:"|?*\x00-\x1F]/
   - Match existing security behavior from ClaudeSessionProvider.ts lines 226-236

2. Export validatePromptsFolder(value: unknown): ValidationResult
   - Empty string is VALID (means global storage)
   - Reject '..' sequences
   - Reject absolute paths (use path.isAbsolute)
   - Match existing behavior from ClaudeSessionProvider.ts lines 134-150

3. Export validateLocalSettingsPropagation(value: unknown): ValidationResult
   - Allowlist: ['copy', 'symlink', 'disabled']
   - Match package.json enum at lines 274-278
   - Return error with allowed values if invalid

4. Export validateCustomWorkflowsFolder(value: unknown): ValidationResult
   - Allow empty or relative paths
   - Reject '..' and absolute paths
   - Similar to promptsFolder validation

All validators return ValidationResult per utils.ts pattern.
  </action>
  <verify>npm run compile passes; all validators match existing package.json schema definitions</verify>
  <done>All 4 config validators reject invalid values with clear error messages mentioning allowed values or specific issues</done>
</task>

<task type="auto">
  <name>Create path security utilities (pathSanitizer.ts)</name>
  <files>src/validation/pathSanitizer.ts</files>
  <action>
Create src/validation/pathSanitizer.ts with safe path resolution:

1. Export safeResolve(basePath: string, relativePath: string): string | null
   - Use path.resolve(basePath, relativePath)
   - Use path.normalize() on both result and base
   - Check if normalized result starts with normalized base
   - Return null if path would escape (traversal detected)
   - Return normalized path if safe

2. Export sanitizeForDisplay(input: string): string
   - Trim whitespace
   - Replace spaces with hyphens
   - Remove invalid chars (keep [\w\-./])
   - Truncate to 50 chars
   - For display purposes only, NOT for security

Use Node.js built-in path module (no external dependencies).
Add JSDoc comments explaining security properties.
  </action>
  <verify>npm run compile passes; safeResolve returns null for traversal attempts like '../../../etc'</verify>
  <done>safeResolve prevents path escape; sanitizeForDisplay produces safe display strings</done>
</task>

<task type="auto">
  <name>Create validation module barrel and integrate validators</name>
  <files>src/validation/index.ts, src/extension.ts, src/ClaudeSessionProvider.ts</files>
  <action>
1. Create src/validation/index.ts barrel file:
   - Export all validators from validators.ts
   - Export all config validators from schemas.ts
   - Export path utilities from pathSanitizer.ts
   - Re-export ValidationResult from utils.ts for convenience

2. Update src/extension.ts createSession handler:
   - Import validateSessionName from validation module
   - BEFORE using message.name in any path operation:
     * Call validateSessionName(message.name)
     * If !valid, throw ValidationError('sessionName', name, error)
   - Keep existing sanitizeSessionName for display purposes only
   - Position: before line with trimmedName assignment

3. Update src/ClaudeSessionProvider.ts getWorktreesFolder:
   - Import validateWorktreesFolder from schemas.ts
   - Call validateWorktreesFolder(folder) before returning
   - If invalid, log warning and return '.worktrees' (existing fallback)
   - Preserve existing security checks as defense-in-depth

Follow Phase 2 pattern: ValidationError('fieldName', value, reason).
  </action>
  <verify>npm run compile passes; existing tests still pass (npm test)</verify>
  <done>Session name validation happens before any path operations; config values validated at read time</done>
</task>

<task type="auto">
  <name>Add security test coverage for validation</name>
  <files>src/test/validation.test.ts</files>
  <action>
Create src/test/validation.test.ts with security test coverage:

1. Session name validation tests:
   - test('rejects session name containing ..')
   - test('rejects session name containing null byte')
   - test('rejects empty session name')
   - test('rejects session name over 200 characters')
   - test('accepts valid session names with slashes')
   - test('accepts valid session names with hyphens and underscores')

2. Path traversal tests:
   - test('safeResolve returns null for ../../../etc/passwd')
   - test('safeResolve returns null for ../sibling')
   - test('safeResolve returns normalized path for safe relative path')
   - test('safeResolve handles complex traversal attempts')

3. Configuration validation tests:
   - test('validateWorktreesFolder rejects path traversal')
   - test('validatePromptsFolder allows empty string (global storage)')
   - test('validateLocalSettingsPropagation rejects invalid enum values')
   - test('validateCustomWorkflowsFolder rejects absolute paths')

4. Integration tests:
   - test('createSession throws ValidationError for malicious session name')
   - test('createSession accepts valid session name with slashes')

Use Mocha test framework (existing pattern).
Use assert.strictEqual for comparisons.
Follow test naming from src/test/branchValidation.test.ts.
  </action>
  <verify>npm test passes; all new tests pass; coverage includes path traversal scenarios</verify>
  <done>All security scenarios tested; path traversal attempts are rejected; valid inputs are accepted</done>
</task>

</tasks>

<verification>
Overall phase verification:
1. Run npm test - all tests including new validation tests pass
2. Try creating session with name '../../../etc' - should see clear ValidationError, not silent acceptance
3. Check all user input paths (createSession, config reads) have validation before use
4. Verify ValidationError messages mention the specific field and issue
5. Confirm no session creation with malicious names succeeds
</verification>

<success_criteria>
1. src/validation/ module exists with 4 files (index.ts, validators.ts, schemas.ts, pathSanitizer.ts)
2. Session names with '..' are rejected before file system operations
3. Configuration values validated at runtime with clear error messages
4. Security test coverage exists for path traversal scenarios
5. All existing tests still pass (backward compatibility maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-validation/03-01-SUMMARY.md`
</output>
