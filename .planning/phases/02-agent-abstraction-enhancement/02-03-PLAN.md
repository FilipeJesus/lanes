---
phase: 02-agent-abstraction-enhancement
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/services/SettingsService.ts
  - src/services/SettingsFormatService.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Settings service reads JSON settings files for Claude"
    - "Settings service reads TOML settings files for Codex"
    - "Settings service writes JSON settings files for Claude"
    - "Settings service writes TOML settings files for Codex"
    - "Format is determined by the CodeAgent, not hardcoded in the service"
    - "TOML library is only loaded when needed (lazy import for Codex sessions)"
    - "Existing Claude JSON settings flow is completely unaffected"
  artifacts:
    - path: "src/services/SettingsFormatService.ts"
      provides: "Format-agnostic settings read/write with JSON and TOML implementations"
      exports: ["SettingsFormat", "JsonSettingsFormat", "TomlSettingsFormat", "getSettingsFormat"]
    - path: "src/services/SettingsService.ts"
      provides: "Updated getOrCreateExtensionSettingsFile using format abstraction"
      contains: "getSettingsFormat"
    - path: "package.json"
      provides: "@iarna/toml dependency for TOML parsing"
      contains: "@iarna/toml"
  key_links:
    - from: "src/services/SettingsService.ts"
      to: "src/services/SettingsFormatService.ts"
      via: "getSettingsFormat(codeAgent) call"
      pattern: "getSettingsFormat"
    - from: "src/services/SettingsFormatService.ts"
      to: "src/codeAgents/CodeAgent.ts"
      via: "Agent name determines format selection"
      pattern: "codeAgent\\.name|settingsFileName"
---

<objective>
Create a format-agnostic settings service that reads and writes both JSON and TOML based on the agent's specification. Add @iarna/toml dependency for TOML parsing. Update SettingsService to use the format abstraction when writing agent settings files.

Purpose: Claude uses JSON for settings, Codex uses TOML. The settings service needs to handle both formats without hardcoding JSON assumptions. Format is determined by the CodeAgent instance.

Output: SettingsFormatService module with JSON/TOML implementations, updated SettingsService, @iarna/toml dependency.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-abstraction-enhancement/02-CONTEXT.md
@.planning/phases/02-agent-abstraction-enhancement/02-RESEARCH.md
@.planning/phases/02-agent-abstraction-enhancement/02-01-SUMMARY.md

@src/services/SettingsService.ts
@src/codeAgents/CodeAgent.ts
@src/codeAgents/ClaudeCodeAgent.ts
@src/localSettings.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @iarna/toml and create SettingsFormatService</name>
  <files>
    package.json
    src/services/SettingsFormatService.ts
  </files>
  <action>
**Install @iarna/toml dependency:**
Run `npm install @iarna/toml` to add the TOML parsing library. This adds it to `package.json` dependencies. Also install the types if available: `npm install --save-dev @types/iarna__toml` (check if this exists; if not, create a minimal type declaration).

If `@types/iarna__toml` does not exist in npm, create `src/types/iarna-toml.d.ts` with:
```typescript
declare module '@iarna/toml' {
    export function parse(input: string): Record<string, unknown>;
    export function stringify(value: Record<string, unknown>): string;
}
```

**Create `src/services/SettingsFormatService.ts`** - Format abstraction with JSON and TOML implementations:

```typescript
/**
 * SettingsFormatService - Format-agnostic settings file reading and writing
 *
 * Provides an abstraction over different settings file formats (JSON, TOML)
 * so the settings service doesn't need to know about format details.
 * The format is determined by the CodeAgent.
 */

import * as fsPromises from 'fs/promises';
import type { CodeAgent } from '../codeAgents';

/**
 * Interface for settings file format handlers.
 * Each format (JSON, TOML) implements this interface.
 */
export interface SettingsFormat {
    /** File extension hint (e.g., '.json', '.toml') */
    readonly extension: string;

    /** Read and parse a settings file */
    read(filePath: string): Promise<Record<string, unknown>>;

    /** Serialize and write a settings file */
    write(filePath: string, data: Record<string, unknown>): Promise<void>;
}

/**
 * JSON settings format handler.
 * Used by Claude Code (settings.json, claude-settings.json).
 */
export class JsonSettingsFormat implements SettingsFormat {
    readonly extension = '.json';

    async read(filePath: string): Promise<Record<string, unknown>> {
        const content = await fsPromises.readFile(filePath, 'utf-8');
        return JSON.parse(content) as Record<string, unknown>;
    }

    async write(filePath: string, data: Record<string, unknown>): Promise<void> {
        await fsPromises.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
    }
}

/**
 * TOML settings format handler.
 * Used by Codex CLI (config.toml).
 * TOML library is lazily imported to avoid loading it for Claude-only sessions.
 */
export class TomlSettingsFormat implements SettingsFormat {
    readonly extension = '.toml';

    async read(filePath: string): Promise<Record<string, unknown>> {
        // Lazy import - only load TOML library when actually needed
        const TOML = await import('@iarna/toml');
        const content = await fsPromises.readFile(filePath, 'utf-8');
        return TOML.parse(content) as Record<string, unknown>;
    }

    async write(filePath: string, data: Record<string, unknown>): Promise<void> {
        // Lazy import - only load TOML library when actually needed
        const TOML = await import('@iarna/toml');
        const tomlString = TOML.stringify(data as any);
        await fsPromises.writeFile(filePath, tomlString, 'utf-8');
    }
}

// Singleton format instances
const jsonFormat = new JsonSettingsFormat();
const tomlFormat = new TomlSettingsFormat();

/**
 * Get the appropriate settings format handler for a code agent.
 * Determines format based on the agent's settings file name extension.
 *
 * @param codeAgent The code agent to get the format for
 * @returns The appropriate SettingsFormat implementation
 */
export function getSettingsFormat(codeAgent: CodeAgent): SettingsFormat {
    const settingsFileName = codeAgent.getSettingsFileName();
    if (settingsFileName.endsWith('.toml')) {
        return tomlFormat;
    }
    // Default to JSON for .json files and any unknown extensions
    return jsonFormat;
}
```

Note on `TOML.stringify(data as any)`: The @iarna/toml `stringify` function expects a specific type. Use `as any` to bridge the generic Record type. This is safe because we control the data being written.
  </action>
  <verify>
Run `npm install` to ensure dependencies are resolved. Run `npm run compile` to verify no TypeScript errors. Verify that:
- `@iarna/toml` appears in `package.json` dependencies
- `src/services/SettingsFormatService.ts` exports `SettingsFormat`, `JsonSettingsFormat`, `TomlSettingsFormat`, `getSettingsFormat`
- Type declarations compile correctly
  </verify>
  <done>
- `@iarna/toml` installed as a dependency
- `SettingsFormatService` provides `SettingsFormat` interface with `read()` and `write()` methods
- `JsonSettingsFormat` handles JSON files (used for Claude)
- `TomlSettingsFormat` handles TOML files with lazy import (used for Codex)
- `getSettingsFormat(codeAgent)` selects format based on agent's settings file extension
- TOML library only loaded when a TOML-using agent is active
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SettingsService to use format abstraction for settings file writing</name>
  <files>
    src/services/SettingsService.ts
  </files>
  <action>
**Update `src/services/SettingsService.ts`** - Use SettingsFormatService for writing settings files:

1. Add import at top:
```typescript
import { getSettingsFormat } from './SettingsFormatService';
```

2. Update `getOrCreateExtensionSettingsFile()` function's file writing section. Currently the function writes the settings file using `JSON.stringify` directly (around line 337-345):

```typescript
// Current code (to be replaced):
const tempPath = path.join(settingsDir, `${settingsFileName}.${Date.now()}.tmp`);
try {
    await fsPromises.writeFile(tempPath, JSON.stringify(settings, null, 2), 'utf-8');
    await fsPromises.rename(tempPath, settingsFilePath);
} catch (err) {
    await fsPromises.unlink(tempPath).catch(() => {});
    throw err;
}
```

Replace with format-aware writing:

```typescript
// Write the settings file atomically with cleanup on failure
// Use format-agnostic writer when CodeAgent is available
const tempPath = path.join(settingsDir, `${settingsFileName}.${Date.now()}.tmp`);
try {
    if (codeAgent) {
        const format = getSettingsFormat(codeAgent);
        await format.write(tempPath, settings as Record<string, unknown>);
    } else {
        // Fallback: JSON for backward compatibility
        await fsPromises.writeFile(tempPath, JSON.stringify(settings, null, 2), 'utf-8');
    }
    await fsPromises.rename(tempPath, settingsFilePath);
} catch (err) {
    // Clean up temp file on failure
    await fsPromises.unlink(tempPath).catch(() => {});
    throw err;
}
```

IMPORTANT: The `ClaudeSettings` type and the hooks generation logic in this function are Claude-specific. For hookless agents (Codex), the settings file should NOT contain hooks (since Codex doesn't use them). Add a guard early in the function:

After the section that generates hooks (around line 257-308), wrap the hooks assignment in a check:

```typescript
// Build hooks configuration (only for agents that support hooks)
let hooks: ClaudeSettings['hooks'] | undefined;

if (codeAgent && !codeAgent.supportsHooks()) {
    // Hookless agents don't need hooks in their settings file
    hooks = undefined;
} else if (codeAgent) {
    // Use CodeAgent to generate hooks
    // ... (existing code for hook generation)
} else {
    // Fallback to hardcoded hooks for backward compatibility
    // ... (existing fallback code)
}
```

Then update the settings object construction:
```typescript
const settings: Record<string, unknown> = {};
if (hooks) {
    settings.hooks = hooks;
}
```

This ensures that for Codex, the settings file (config.toml) is written without a hooks section. The file may be nearly empty for now - that's fine; Phase 3 will add Codex-specific settings content.

Also, for hookless agents, skip the hook script generation (the artefact registration shell script around lines 211-244). Wrap it in:
```typescript
// Generate hook script only for agents that support hooks
if (!codeAgent || codeAgent.supportsHooks()) {
    const hookScriptPath = path.join(settingsDir, 'register-artefact.sh');
    // ... existing hook script generation code ...
}
```

Make sure `hookScriptPath` is declared with `let` before the conditional block so it's available to the hooks generation code:
```typescript
let hookScriptPath: string | undefined;
if (!codeAgent || codeAgent.supportsHooks()) {
    hookScriptPath = path.join(settingsDir, 'register-artefact.sh');
    // ... existing hook script content and writeFile ...
}
```
  </action>
  <verify>
Run `npm run compile` to verify no TypeScript errors. Run `npm test` to verify existing tests pass. Verify that:
- `getSettingsFormat` is imported and used in SettingsService
- Settings are written using format abstraction when codeAgent is provided
- Hookless agents get settings files without hooks section
- Claude settings still written as JSON with hooks (unchanged behavior)
  </verify>
  <done>
- SettingsService uses `getSettingsFormat(codeAgent)` for format-aware file writing
- Claude settings: written as JSON with hooks (behavior unchanged)
- Codex settings: written as TOML without hooks section
- Hook script generation skipped for hookless agents
- Atomic write pattern preserved (temp file + rename)
- Fallback to JSON when no codeAgent is provided (backward compatibility)
  </done>
</task>

</tasks>

<verification>
1. `npm run compile` passes with zero errors
2. `npm test` passes with all existing tests unchanged
3. `@iarna/toml` in `package.json` dependencies
4. `SettingsFormatService.ts` exists with JSON and TOML format handlers
5. `SettingsService.ts` imports and uses `getSettingsFormat`
6. Claude settings: JSON with hooks (verified by grep for JSON.stringify fallback)
7. Hookless agents: settings without hooks section (verified by grep for supportsHooks check)
</verification>

<success_criteria>
- `@iarna/toml` installed and compiles
- `getSettingsFormat()` returns `JsonSettingsFormat` for Claude, `TomlSettingsFormat` for Codex
- TOML library lazily imported (only when Codex sessions are created)
- Existing Claude JSON settings flow completely unaffected
- Hookless agents get settings files without hooks or hook scripts
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-abstraction-enhancement/02-03-SUMMARY.md`
</output>
