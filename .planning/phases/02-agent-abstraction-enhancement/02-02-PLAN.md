---
phase: 02-agent-abstraction-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/AgentSessionProvider.ts
  - src/services/SessionService.ts
  - src/services/TerminalService.ts
autonomous: true

must_haves:
  truths:
    - "New sessions always include the agentName field in the session file"
    - "Existing session files without agentName field are treated as implicitly Claude"
    - "Lanes writes the session file itself when creating a hookless agent terminal"
    - "Status for hookless agents is tracked via terminal open/close events only (active/idle, not working/waiting)"
    - "Session metadata persists across extension restarts"
    - "Session file name remains .claude-session for all agents regardless of agent type"
  artifacts:
    - path: "src/AgentSessionProvider.ts"
      provides: "AgentSessionData with optional agentName field, backward-compatible reading"
      contains: "agentName"
    - path: "src/services/SessionService.ts"
      provides: "Session creation writes agentName to session file"
      contains: "agentName"
    - path: "src/services/TerminalService.ts"
      provides: "Hookless agent session file writing on terminal creation, terminal lifecycle tracking"
      contains: "supportsHooks\\|onDidCloseTerminal\\|writeSessionFile"
  key_links:
    - from: "src/services/SessionService.ts"
      to: "src/AgentSessionProvider.ts"
      via: "saveSessionWorkflow and session file creation with agentName"
      pattern: "agentName"
    - from: "src/services/TerminalService.ts"
      to: "src/AgentSessionProvider.ts"
      via: "Writes session file for hookless agents, reads session data"
      pattern: "getSessionFilePath.*agentName"
    - from: "src/services/TerminalService.ts"
      to: "src/codeAgents/CodeAgent.ts"
      via: "Checks supportsHooks() to determine tracking strategy"
      pattern: "supportsHooks"
---

<objective>
Add per-session agent metadata persistence and hookless session tracking infrastructure. Session files get an `agentName` field (backward-compatible: missing = Claude). For agents without hooks (like Codex), Lanes writes the session file directly and tracks status via terminal open/close events.

Purpose: Sessions must know which agent created them (for resume, for correct factory lookup on restart). Hookless agents need an alternative to Claude's hook-based session ID capture and status tracking.

Output: Updated session data model, agent-aware session creation, hookless terminal tracking in TerminalService.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-abstraction-enhancement/02-CONTEXT.md
@.planning/phases/02-agent-abstraction-enhancement/02-RESEARCH.md
@.planning/phases/02-agent-abstraction-enhancement/02-01-SUMMARY.md

@src/AgentSessionProvider.ts
@src/services/SessionService.ts
@src/services/TerminalService.ts
@src/codeAgents/CodeAgent.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add agentName to session data model and update session creation</name>
  <files>
    src/AgentSessionProvider.ts
    src/services/SessionService.ts
    src/codeAgents/CodeAgent.ts
  </files>
  <action>
**Update `src/codeAgents/CodeAgent.ts`** - Add `supportsHooks()` method to the abstract base class:

Add a new method to the CodeAgent abstract class (after the `getHookEvents()` abstract method):
```typescript
/**
 * Check if this agent supports a hook system for session tracking.
 * When true, the agent's CLI handles session file writes via hooks.
 * When false, Lanes manages session files directly.
 * Default: true (assumes hook support; hookless agents override to return false)
 */
supportsHooks(): boolean {
    return this.getHookEvents().length > 0;
}
```

This is NOT abstract - it has a default implementation that infers hook support from `getHookEvents()`. ClaudeCodeAgent returns `['SessionStart', 'Stop', ...]` so `supportsHooks()` returns true. CodexAgent returns `[]` so `supportsHooks()` returns false. No changes needed to ClaudeCodeAgent or CodexAgent.

**Update `src/AgentSessionProvider.ts`** - Add `agentName` to `AgentSessionData` interface and update session reading:

1. Add `agentName?: string` to the `AgentSessionData` interface (after `permissionMode?`). It is optional for backward compatibility.

2. Update `getSessionId()` function: When reading session data, include `agentName` in the returned object. In the `globalCodeAgent` branch, after getting `sessionData` from `globalCodeAgent.parseSessionData(content)`, return `agentName: sessionData.agentName`. In the legacy fallback branch, set `agentName: data.agentName || 'claude'` (missing field = implicit Claude per user decision).

3. Add a new exported function `getSessionAgentName(worktreePath: string): Promise<string>`:
```typescript
export async function getSessionAgentName(worktreePath: string): Promise<string> {
    const sessionPath = getSessionFilePath(worktreePath);
    try {
        const data = await readJson<Record<string, unknown>>(sessionPath);
        if (!data) { return 'claude'; }
        if (typeof data.agentName === 'string' && data.agentName.trim() !== '') {
            return data.agentName;
        }
        // Missing agentName field = implicit Claude (backward compatibility)
        return 'claude';
    } catch { return 'claude'; }
}
```

**Update `src/services/SessionService.ts`** - Ensure new sessions always write `agentName`:

In the `createSession()` function, after the worktree is created and before `sessionProvider.refresh()` is called (around the section after propagateLocalSettings), add logic to write the initial session file for hookless agents. But more importantly, ensure ALL session creation paths include `agentName`.

The session file writing currently happens via hooks (Claude) or needs to happen directly (hookless agents). Add this block after the `propagateLocalSettings` call and before `sessionProvider.refresh()`:

```typescript
// Write initial session file for hookless agents
// For hook-based agents (Claude), the hook writes the session file on SessionStart
// For hookless agents (Codex), Lanes must write it directly
if (codeAgent && !codeAgent.supportsHooks()) {
    const { getSessionFilePath } = await import('../AgentSessionProvider');
    const { ensureDir, writeJson } = await import('./FileService');
    const sessionFilePath = getSessionFilePath(worktreePath);
    await ensureDir(path.dirname(sessionFilePath));
    await writeJson(sessionFilePath, {
        agentName: codeAgent.name,
        timestamp: new Date().toISOString()
        // sessionId will be captured later from terminal output
    });
}
```

Note: Use static imports at the top of the file instead of dynamic imports if `getSessionFilePath`, `ensureDir`, `writeJson` are already imported. `getSessionFilePath` is already imported from `../AgentSessionProvider`. Check existing imports and reuse them. `ensureDir` and `writeJson` need to be imported from `./FileService` if not already.

Also import `supportsHooks` is not needed - it's a method on the CodeAgent instance passed in.
  </action>
  <verify>
Run `npm run compile` to verify no TypeScript errors. Run `npm test` to verify existing tests pass. Check that `AgentSessionData` interface includes `agentName`. Verify `getSessionAgentName` is exported from AgentSessionProvider.
  </verify>
  <done>
- `AgentSessionData` has optional `agentName` field
- `getSessionId()` returns `agentName` in its result (defaults to 'claude' for legacy files)
- `getSessionAgentName()` exported for direct agent name lookup
- `createSession()` writes session file with `agentName` for hookless agents
- `supportsHooks()` method on CodeAgent base class infers hook support from `getHookEvents()`
- Backward compatibility: missing `agentName` = implicit Claude
  </done>
</task>

<task type="auto">
  <name>Task 2: Add hookless terminal lifecycle tracking in TerminalService</name>
  <files>
    src/services/TerminalService.ts
    src/extension.ts
  </files>
  <action>
**Update `src/services/TerminalService.ts`** - Add hookless session tracking via terminal events:

1. Add imports at the top:
- `import { getSessionFilePath, getStatusFilePath } from '../AgentSessionProvider'`  (if not already imported)
- `import { ensureDir, writeJson } from './FileService'` (if not already imported)

2. Add a module-level Map to track hookless agent terminals:
```typescript
/** Tracks terminals for hookless agents: terminal -> worktreePath */
const hooklessTerminals = new Map<vscode.Terminal, string>();
```

3. Add a new exported function `registerHooklessTerminalTracking(context: vscode.ExtensionContext): void`:
```typescript
/**
 * Register terminal lifecycle tracking for hookless agents.
 * Hookless agents (like Codex) don't have a hook system to write status files.
 * Instead, we track terminal open/close events to write simple active/idle status.
 *
 * This function should be called once during extension activation.
 */
export function registerHooklessTerminalTracking(context: vscode.ExtensionContext): void {
    // Track terminal close - update status to idle
    context.subscriptions.push(
        vscode.window.onDidCloseTerminal((terminal: vscode.Terminal) => {
            const worktreePath = hooklessTerminals.get(terminal);
            if (worktreePath) {
                // Write idle status (terminal closed)
                const statusPath = getStatusFilePath(worktreePath);
                ensureDir(path.dirname(statusPath)).then(() =>
                    writeJson(statusPath, {
                        status: 'idle',
                        timestamp: new Date().toISOString()
                    })
                ).catch(err => {
                    console.warn('Lanes: Failed to write idle status for hookless agent:', err);
                });
                hooklessTerminals.delete(terminal);
            }
        })
    );
}
```

4. Add a new exported function `trackHooklessTerminal(terminal: vscode.Terminal, worktreePath: string): void`:
```typescript
/**
 * Register a terminal as belonging to a hookless agent session.
 * Called when creating a terminal for a hookless agent.
 * Writes 'active' status immediately and registers for close tracking.
 */
export async function trackHooklessTerminal(terminal: vscode.Terminal, worktreePath: string): Promise<void> {
    hooklessTerminals.set(terminal, worktreePath);

    // Write active status (terminal opened)
    try {
        const statusPath = getStatusFilePath(worktreePath);
        await ensureDir(path.dirname(statusPath));
        await writeJson(statusPath, {
            status: 'active',
            timestamp: new Date().toISOString()
        });
    } catch (err) {
        console.warn('Lanes: Failed to write active status for hookless agent:', err);
    }
}
```

5. Update the `openAgentTerminal()` function - After the terminal is created and `terminal.show()` is called (around line 192), add hookless tracking:

After `terminal.show()`, add:
```typescript
// Track hookless agent terminals for lifecycle status updates
if (codeAgent && !codeAgent.supportsHooks()) {
    await trackHooklessTerminal(terminal, worktreePath);
}
```

**Update `src/extension.ts`** - Register hookless terminal tracking during activation:

1. Add import: `import { registerHooklessTerminalTracking } from './services/TerminalService'` (add to existing TerminalService imports - note: `openAgentTerminal` is already imported from TerminalService).

Actually, check the existing imports. Line 49 already has `import { openAgentTerminal } from './services/TerminalService'`. Add `registerHooklessTerminalTracking` to this import.

2. Call `registerHooklessTerminalTracking(context)` in the `activate()` function, right after `SessionService.setOpenAgentTerminal(TerminalService.openAgentTerminal)` (around line 64). This registers the terminal close listener once during activation.

```typescript
// Register hookless terminal tracking for agents without hook systems
TerminalService.registerHooklessTerminalTracking(context);
```

Wait - the import on line 49 uses a named import directly. The import on line 39 imports the namespace `* as TerminalService`. Use the namespace import pattern to stay consistent: `TerminalService.registerHooklessTerminalTracking(context)`.

Actually, looking more carefully at extension.ts:
- Line 39: `import * as TerminalService from './services/TerminalService';`
- Line 49: `import { openAgentTerminal } from './services/TerminalService';`

Both exist. Use the namespace import for the call: `TerminalService.registerHooklessTerminalTracking(context);`

No need to add a new import line - `TerminalService` namespace is already imported.
  </action>
  <verify>
Run `npm run compile` to verify no TypeScript errors. Run `npm test` to verify existing tests pass. Verify that:
- `registerHooklessTerminalTracking` is exported from TerminalService
- `trackHooklessTerminal` is exported from TerminalService
- Extension calls `registerHooklessTerminalTracking` during activation
- `openAgentTerminal` calls `trackHooklessTerminal` for hookless agents
  </verify>
  <done>
- Hookless terminals tracked via `Map<Terminal, worktreePath>`
- Terminal close writes `{ status: 'idle' }` to status file
- Terminal open writes `{ status: 'active' }` to status file
- `openAgentTerminal()` automatically tracks hookless agents
- Extension registers terminal close listener during activation
- Hook-based agents (Claude) are unaffected - their hooks still manage status
  </done>
</task>

</tasks>

<verification>
1. `npm run compile` passes with zero errors
2. `npm test` passes with all existing tests unchanged
3. `AgentSessionData` interface has `agentName?: string` field
4. `getSessionAgentName()` is exported from AgentSessionProvider
5. `supportsHooks()` returns true for Claude (has hook events) and false for Codex (empty hook events)
6. Hookless agents get session file written during `createSession()`
7. Hookless agents get status tracking via terminal open/close events
8. Existing Claude hook-based tracking is completely unaffected
</verification>

<success_criteria>
- Session files written for hookless agents include `agentName` field
- Existing session files without `agentName` are treated as Claude (no migration)
- Hookless agent terminals write active/idle status on open/close
- Hook-based agents (Claude) continue using their hook system unchanged
- `supportsHooks()` correctly distinguishes agent tracking strategies
- All backward compatibility maintained
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-abstraction-enhancement/02-02-SUMMARY.md`
</output>
