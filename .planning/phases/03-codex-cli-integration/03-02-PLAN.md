---
phase: 03-codex-cli-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/codeAgents/CodexAgent.ts
  - src/services/TerminalService.ts
autonomous: true

must_haves:
  truths:
    - "After a Codex terminal starts, the extension polls ~/.codex/sessions/ to find the new session ID"
    - "Captured session ID is written back to the worktree session file so resume works"
    - "If session ID capture fails (timeout), user sees an error message suggesting to start a new session"
    - "Session ID capture does NOT silently fall back to --last"
    - "Claude Code sessions are unaffected by the capture logic (only runs for hookless agents)"
  artifacts:
    - path: "src/codeAgents/CodexAgent.ts"
      provides: "captureSessionId() static method for filesystem-based session ID polling"
      contains: "captureSessionId"
    - path: "src/services/TerminalService.ts"
      provides: "Post-start session ID capture integration for hookless agents"
      contains: "captureSessionId"
  key_links:
    - from: "src/services/TerminalService.ts"
      to: "src/codeAgents/CodexAgent.ts"
      via: "calls captureSessionId after sendText for hookless agents"
      pattern: "captureSessionId"
    - from: "src/services/TerminalService.ts"
      to: "src/AgentSessionProvider.ts"
      via: "writes captured sessionId to session file"
      pattern: "writeJson.*sessionId|sessionFilePath"
---

<objective>
Implement Codex session ID capture via filesystem polling and integrate into terminal startup flow

Purpose: Without session ID capture, Codex sessions cannot be resumed. Claude uses hooks to write session IDs; Codex has no hooks, so the extension must capture the session ID by polling Codex's session directory after terminal startup. This is critical for REQ-C5 (session tracking) and REQ-C3 (resume capability).

Output: Session ID capture method on CodexAgent, integrated into TerminalService post-start flow
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-codex-cli-integration/03-CONTEXT.md
@.planning/phases/03-codex-cli-integration/03-RESEARCH.md
@src/codeAgents/CodexAgent.ts
@src/codeAgents/CodeAgent.ts
@src/services/TerminalService.ts
@src/services/SessionService.ts
@src/AgentSessionProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add captureSessionId to CodexAgent</name>
  <files>src/codeAgents/CodexAgent.ts</files>
  <action>
Add a static async method `captureSessionId` to CodexAgent that polls `~/.codex/sessions/` to find a newly created session file and extract the session ID.

**Implementation:**

```typescript
import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs/promises';
```

Add static method to CodexAgent class:

```typescript
/**
 * Capture Codex session ID by reading the most recently modified session file
 * from ~/.codex/sessions/. Polls with a 500ms interval until timeout.
 *
 * @param beforeTimestamp Only consider files modified after this time (to filter pre-existing sessions)
 * @param timeoutMs Maximum time to wait (default: 10000ms -- generous for slow starts)
 * @param pollIntervalMs Poll interval (default: 500ms)
 * @returns Session ID string (UUID format) or null if capture fails
 */
static async captureSessionId(
    beforeTimestamp: Date,
    timeoutMs: number = 10000,
    pollIntervalMs: number = 500
): Promise<string | null>
```

**Logic:**
1. Compute sessions dir: `path.join(os.homedir(), '.codex', 'sessions')`
2. Poll loop: while elapsed < timeoutMs
3. Each iteration: `fs.readdir(sessionsDir)` -- if dir doesn't exist, wait and retry
4. For each file, `fs.stat()` to get mtime; filter files with mtime > beforeTimestamp
5. Sort by mtime descending, take the newest file
6. Read file content (JSONL format -- first line)
7. Parse JSON from first line
8. Try multiple field names for session ID: `session_id`, `id`, `sessionId` (research says field name uncertain)
9. Validate extracted ID against UUID regex
10. If valid UUID found, return it
11. If no valid file found, `await new Promise(resolve => setTimeout(resolve, pollIntervalMs))` and retry
12. On timeout or error, return null
13. Wrap entire function in try/catch, log errors, return null on failure

**Important:** Use 10s timeout (not 5s from research) to be generous for slow machine startups. The `beforeTimestamp` parameter is critical -- it ensures we only pick up NEW session files created after the terminal command was sent, not pre-existing ones from previous sessions.
  </action>
  <verify>
Run `npm run compile` to verify TypeScript compilation succeeds.
  </verify>
  <done>
CodexAgent has a static `captureSessionId` method that polls `~/.codex/sessions/`, filters by timestamp, extracts UUID session IDs from JSONL files, and returns the ID or null on timeout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate session ID capture into TerminalService post-start flow</name>
  <files>src/services/TerminalService.ts</files>
  <action>
After a hookless agent's start command is sent to the terminal, trigger async session ID capture and write the result back to the session file. This must be non-blocking (fire-and-forget with error handling).

**In `openAgentTerminal()`, find the section after `terminal.sendText(startCommand)` for the fresh start path (the `shouldStartFresh` block).**

After the start command is sent (and ONLY for hookless agents starting fresh, NOT for resume), add:

```typescript
// For hookless agents, capture session ID asynchronously after start
if (codeAgent && !codeAgent.supportsHooks()) {
    // Import at top of file: import { CodexAgent } from '../codeAgents/CodexAgent';
    // Record timestamp before command was sent (for filtering pre-existing sessions)
    // Note: beforeTimestamp should be captured BEFORE sendText, so move this declaration
    // up to just before the sendText call
    captureHooklessSessionId(codeAgent, worktreePath, beforeStartTimestamp);
}
```

**Add a new private async function `captureHooklessSessionId`:**

```typescript
/**
 * Asynchronously capture session ID for a hookless agent and write it to the session file.
 * This is fire-and-forget -- errors are logged but don't block terminal creation.
 *
 * LOCKED DECISION: If capture fails, show error to user suggesting to start a new session.
 * Do NOT silently fall back to --last.
 */
async function captureHooklessSessionId(
    codeAgent: CodeAgent,
    worktreePath: string,
    beforeTimestamp: Date
): Promise<void> {
    try {
        // Currently only CodexAgent supports session capture via filesystem
        // Other hookless agents would need their own capture mechanism
        const { CodexAgent } = await import('../codeAgents/CodexAgent');
        if (!(codeAgent instanceof CodexAgent)) {
            return; // No capture mechanism for this hookless agent
        }

        const sessionId = await CodexAgent.captureSessionId(beforeTimestamp);

        if (!sessionId) {
            // LOCKED DECISION: strict error, no silent fallback
            vscode.window.showWarningMessage(
                'Lanes: Could not capture Codex session ID. Resume may not work for this session. ' +
                'If you need to resume, try starting a new session.'
            );
            return;
        }

        // Write captured session ID back to the session file (merge with existing data)
        const sessionFilePath = getSessionFilePath(worktreePath);
        const { readJson, writeJson } = await import('./FileService');
        let existingData: Record<string, unknown> = {};
        const parsed = await readJson<Record<string, unknown>>(sessionFilePath);
        if (parsed) { existingData = parsed; }
        await writeJson(sessionFilePath, {
            ...existingData,
            sessionId,
            timestamp: new Date().toISOString()
        });

        console.log(`Lanes: Captured Codex session ID: ${sessionId}`);
    } catch (err) {
        console.error('Lanes: Failed to capture hookless session ID:', getErrorMessage(err));
        vscode.window.showWarningMessage(
            'Lanes: Could not capture Codex session ID. Resume may not work for this session. ' +
            'If you need to resume, try starting a new session.'
        );
    }
}
```

**Key integration points in `openAgentTerminal()`:**

1. Add `const beforeStartTimestamp = new Date();` just BEFORE the `shouldStartFresh` block where start commands are sent
2. After all three paths of sending the start command (codeAgent with prompt file, codeAgent with escaped prompt, codeAgent without prompt), add the hookless capture call
3. The capture is async but not awaited in the main flow -- use `.catch()` or just call the async function (it handles its own errors internally)
4. Only trigger for fresh starts, NOT for resume (resume already has a session ID)

**Add import at top of file:**
```typescript
import { getSessionFilePath } from '../AgentSessionProvider';
```
(Check if already imported -- it may already be available via existing imports.)

**Do NOT modify the resume path.** Session ID capture is only needed for fresh starts.
  </action>
  <verify>
Run `npm run compile` to verify TypeScript compilation succeeds. Run `npm run lint` to verify no lint issues. Run `npm test` to ensure existing tests still pass. Verify that the capture function is only called for hookless agents on fresh start (not resume).
  </verify>
  <done>
After a Codex terminal starts fresh, the extension asynchronously polls `~/.codex/sessions/` for the session ID. If captured, it's written to the worktree's session file enabling future resume. If capture fails, user sees a warning message suggesting to start a new session. Claude Code sessions are completely unaffected. No silent `--last` fallback occurs.
  </done>
</task>

</tasks>

<verification>
- `npm run compile` passes
- `npm run lint` passes
- `npm test` passes (no regression)
- CodexAgent.ts contains static `captureSessionId` method
- TerminalService.ts calls `captureHooklessSessionId` only for hookless agents on fresh start
- TerminalService.ts does NOT call capture on resume path
- Warning message on capture failure mentions "start a new session" (not "resume --last")
- `getSessionFilePath` import is present in TerminalService.ts
- No changes to ClaudeCodeAgent or its hook-based session ID flow
</verification>

<success_criteria>
Hookless session ID capture works via filesystem polling. Integration is non-blocking and handles errors gracefully. Strict error behavior matches locked decision (warning to user, no silent fallback). Claude sessions are completely unaffected. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-codex-cli-integration/03-02-SUMMARY.md`
</output>
