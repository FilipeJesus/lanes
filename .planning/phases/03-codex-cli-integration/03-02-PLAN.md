---
phase: 03-codex-cli-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/codeAgents/CodexAgent.ts
  - src/services/TerminalService.ts
autonomous: true

must_haves:
  truths:
    - "After a Codex terminal starts, the extension polls ~/.codex/sessions/ to find the new session ID"
    - "Captured session ID is written back to the worktree session file so resume works"
    - "If session ID capture fails (timeout), user sees an error message suggesting to start a new session"
    - "Session ID capture does NOT silently fall back to --last"
    - "Claude Code sessions are unaffected by the capture logic (only runs for hookless agents)"
  artifacts:
    - path: "src/codeAgents/CodexAgent.ts"
      provides: "captureSessionId() static method for filesystem-based session ID polling"
      contains: "captureSessionId"
    - path: "src/services/TerminalService.ts"
      provides: "Post-start session ID capture integration for hookless agents"
      contains: "captureHooklessSessionId"
  key_links:
    - from: "src/services/TerminalService.ts"
      to: "src/codeAgents/CodexAgent.ts"
      via: "calls captureSessionId after sendText for hookless agents"
      pattern: "captureSessionId"
    - from: "src/services/TerminalService.ts"
      to: "src/AgentSessionProvider.ts"
      via: "writes captured sessionId to session file"
      pattern: "writeJson.*sessionId|sessionFilePath"
---

<objective>
Implement Codex session ID capture via filesystem polling and integrate into terminal startup flow

Purpose: Without session ID capture, Codex sessions cannot be resumed. Claude uses hooks to write session IDs; Codex has no hooks, so the extension must capture the session ID by polling Codex's session directory after terminal startup. This is critical for REQ-C5 (session tracking) and REQ-C3 (resume capability).

Output: Session ID capture method on CodexAgent, integrated into TerminalService post-start flow
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-codex-cli-integration/03-CONTEXT.md
@.planning/phases/03-codex-cli-integration/03-RESEARCH.md
@src/codeAgents/CodexAgent.ts
@src/codeAgents/CodeAgent.ts
@src/services/TerminalService.ts
@src/services/SessionService.ts
@src/AgentSessionProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add captureSessionId to CodexAgent</name>
  <files>src/codeAgents/CodexAgent.ts</files>
  <action>
Add a static async method `captureSessionId` to CodexAgent that polls `~/.codex/sessions/` to find a newly created session file and extract the session ID.

**Implementation:**

```typescript
import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs/promises';
```

Add static method to CodexAgent class:

```typescript
/**
 * Capture Codex session ID by reading the most recently modified session file
 * from ~/.codex/sessions/. Polls with a 500ms interval until timeout.
 *
 * @param beforeTimestamp Only consider files modified after this time (to filter pre-existing sessions)
 * @param timeoutMs Maximum time to wait (default: 10000ms -- generous for slow starts)
 * @param pollIntervalMs Poll interval (default: 500ms)
 * @returns Session ID string (UUID format) or null if capture fails
 */
static async captureSessionId(
    beforeTimestamp: Date,
    timeoutMs: number = 10000,
    pollIntervalMs: number = 500
): Promise<string | null>
```

**Logic:**
1. Compute sessions dir: `path.join(os.homedir(), '.codex', 'sessions')`
2. Poll loop: while elapsed < timeoutMs
3. Each iteration: `fs.readdir(sessionsDir)` -- if dir doesn't exist, wait and retry
4. For each file, `fs.stat()` to get mtime; filter files with mtime > beforeTimestamp
5. Sort by mtime descending, take the newest file
6. Read file content (JSONL format -- first line)
7. Parse JSON from first line
8. Try multiple field names for session ID: `session_id`, `id`, `sessionId` (research says field name uncertain)
9. Validate extracted ID against UUID regex
10. If valid UUID found, return it
11. If no valid file found, `await new Promise(resolve => setTimeout(resolve, pollIntervalMs))` and retry
12. On timeout or error, return null
13. Wrap entire function in try/catch, log errors, return null on failure

**Important:** Use 10s timeout (not 5s from research) to be generous for slow machine startups. The `beforeTimestamp` parameter is critical -- it ensures we only pick up NEW session files created after the terminal command was sent, not pre-existing ones from previous sessions.
  </action>
  <verify>
Run `npm run compile` to verify TypeScript compilation succeeds.
  </verify>
  <done>
CodexAgent has a static `captureSessionId` method that polls `~/.codex/sessions/`, filters by timestamp, extracts UUID session IDs from JSONL files, and returns the ID or null on timeout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add captureHooklessSessionId helper function to TerminalService</name>
  <files>src/services/TerminalService.ts</files>
  <action>
Add a standalone async helper function `captureHooklessSessionId` to TerminalService.ts that handles the full lifecycle of capturing a session ID for a hookless agent and writing it to the session file. This function is self-contained with its own error handling -- it will be called fire-and-forget from the main flow (Task 3).

**Add the function (module-level, not inside a class) near the bottom of TerminalService.ts or in a logical grouping with other helper functions:**

```typescript
/**
 * Asynchronously capture session ID for a hookless agent and write it to the session file.
 * This is designed to be called fire-and-forget -- errors are logged but don't block terminal creation.
 *
 * LOCKED DECISION: If capture fails, show error to user suggesting to start a new session.
 * Do NOT silently fall back to --last.
 */
async function captureHooklessSessionId(
    codeAgent: CodeAgent,
    worktreePath: string,
    beforeTimestamp: Date
): Promise<void> {
    try {
        // Currently only CodexAgent supports session capture via filesystem
        // Other hookless agents would need their own capture mechanism
        const { CodexAgent } = await import('../codeAgents/CodexAgent');
        if (!(codeAgent instanceof CodexAgent)) {
            return; // No capture mechanism for this hookless agent
        }

        const sessionId = await CodexAgent.captureSessionId(beforeTimestamp);

        if (!sessionId) {
            // LOCKED DECISION: strict error, no silent fallback
            vscode.window.showWarningMessage(
                'Lanes: Could not capture Codex session ID. Resume may not work for this session. ' +
                'If you need to resume, try starting a new session.'
            );
            return;
        }

        // Write captured session ID back to the session file (merge with existing data)
        const sessionFilePath = getSessionFilePath(worktreePath);
        const { readJson, writeJson } = await import('./FileService');
        let existingData: Record<string, unknown> = {};
        const parsed = await readJson<Record<string, unknown>>(sessionFilePath);
        if (parsed) { existingData = parsed; }
        await writeJson(sessionFilePath, {
            ...existingData,
            sessionId,
            timestamp: new Date().toISOString()
        });

        console.log(`Lanes: Captured Codex session ID: ${sessionId}`);
    } catch (err) {
        console.error('Lanes: Failed to capture hookless session ID:', getErrorMessage(err));
        vscode.window.showWarningMessage(
            'Lanes: Could not capture Codex session ID. Resume may not work for this session. ' +
            'If you need to resume, try starting a new session.'
        );
    }
}
```

**Required imports (add at top of file if not already present):**
```typescript
import { getSessionFilePath } from '../AgentSessionProvider';
```

Check if `CodeAgent` type, `vscode`, and `getErrorMessage` are already imported -- they likely are since TerminalService already uses them. The dynamic `import('../codeAgents/CodexAgent')` avoids circular dependency issues and keeps CodexAgent as a lazy dependency.

**Do NOT yet modify `openAgentTerminal()`.** This task only adds the helper function and its import. Task 3 wires it in.
  </action>
  <verify>
Run `npm run compile` to verify TypeScript compilation succeeds. The function should compile cleanly even though it's not yet called from anywhere (tree-shaking is not relevant at compile time).
  </verify>
  <done>
`captureHooklessSessionId` function exists in TerminalService.ts as a standalone async helper. It handles CodexAgent instanceof check, calls `captureSessionId`, writes result to session file, and shows warning on failure (per locked decision: no silent --last fallback). Import for `getSessionFilePath` is present.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate capture into openAgentTerminal post-start flow</name>
  <files>src/services/TerminalService.ts</files>
  <action>
Wire the `captureHooklessSessionId` helper (from Task 2) into the `openAgentTerminal()` method so it fires after a hookless agent starts fresh.

**Modifications to `openAgentTerminal()`:**

1. **Add timestamp capture before the start command is sent.** In the `shouldStartFresh` block, just BEFORE the line that calls `terminal.sendText(startCommand)`, add:
```typescript
const beforeStartTimestamp = new Date();
```
This timestamp is used by `captureSessionId` to filter out pre-existing session files.

2. **After the start command is sent, trigger capture for hookless agents.** After all three paths of sending the start command (codeAgent with prompt file, codeAgent with escaped prompt, codeAgent without prompt), add:
```typescript
// For hookless agents, capture session ID asynchronously after start
if (codeAgent && !codeAgent.supportsHooks()) {
    captureHooklessSessionId(codeAgent, worktreePath, beforeStartTimestamp);
}
```

**Critical constraints:**
- The `captureHooklessSessionId` call is NOT awaited -- it runs fire-and-forget. The function handles its own errors internally, so no `.catch()` is needed either (the try/catch inside the function covers everything).
- Only trigger for fresh starts (`shouldStartFresh` path), NOT for resume. The resume path already has a session ID.
- Only trigger when `codeAgent` exists AND `!codeAgent.supportsHooks()`. Claude Code agents use hooks and should not be affected.
- The `beforeStartTimestamp` must be captured BEFORE `sendText` is called, not after, to ensure the timestamp predates the Codex process startup.

**Do NOT modify the resume path.** Session ID capture is only needed for fresh starts.
  </action>
  <verify>
Run `npm run compile` to verify TypeScript compilation succeeds. Run `npm run lint` to verify no lint issues. Run `npm test` to ensure existing tests still pass. Verify that the capture function is only called for hookless agents on fresh start (not resume) by reading through the modified code.
  </verify>
  <done>
After a Codex terminal starts fresh, `openAgentTerminal` calls `captureHooklessSessionId` fire-and-forget. The timestamp is captured before `sendText` so only new session files are detected. Claude Code sessions are completely unaffected (guarded by `!supportsHooks()`). Resume path is unchanged.
  </done>
</task>

</tasks>

<verification>
- `npm run compile` passes
- `npm run lint` passes
- `npm test` passes (no regression)
- CodexAgent.ts contains static `captureSessionId` method
- TerminalService.ts contains `captureHooklessSessionId` helper function
- TerminalService.ts calls `captureHooklessSessionId` only for hookless agents on fresh start
- TerminalService.ts does NOT call capture on resume path
- Warning message on capture failure mentions "start a new session" (not "resume --last")
- `getSessionFilePath` import is present in TerminalService.ts
- No changes to ClaudeCodeAgent or its hook-based session ID flow
</verification>

<success_criteria>
Hookless session ID capture works via filesystem polling. Integration is non-blocking and handles errors gracefully. Strict error behavior matches locked decision (warning to user, no silent fallback). Claude sessions are completely unaffected. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-codex-cli-integration/03-02-SUMMARY.md`
</output>
