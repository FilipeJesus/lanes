---
phase: 05-testing-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/codeAgents/factory.ts
  - src/codeAgents/CodexAgent.ts
  - src/AgentSessionProvider.ts
  - src/test/codeAgents/codex-agent.test.ts
  - src/test/codeAgents/agent-factory.test.ts
autonomous: true

must_haves:
  truths:
    - "isCliAvailable() uses execFile with args array, not exec with string interpolation"
    - "isCliAvailable() uses shell:true instead of hardcoded /bin/sh"
    - "AgentStatusState type includes 'active' alongside existing states"
    - "captureSessionId validates file paths stay within sessions directory"
    - "CodexAgent command building produces correct CLI strings with proper escaping"
    - "CodexAgent UUID validation rejects invalid formats and accepts valid ones"
    - "Agent factory returns correct agent types and handles unknown names"
    - "CLI availability check rejects command injection attempts"
  artifacts:
    - path: "src/codeAgents/factory.ts"
      provides: "Secure CLI check using execFile"
      contains: "execFile"
    - path: "src/AgentSessionProvider.ts"
      provides: "AgentStatusState with active"
      contains: "'active'"
    - path: "src/codeAgents/CodexAgent.ts"
      provides: "Path traversal protection in captureSessionId"
      contains: "path.resolve"
    - path: "src/test/codeAgents/codex-agent.test.ts"
      provides: "CodexAgent unit tests"
      min_lines: 80
    - path: "src/test/codeAgents/agent-factory.test.ts"
      provides: "Factory and CLI availability tests"
      min_lines: 60
  key_links:
    - from: "src/codeAgents/factory.ts"
      to: "child_process.execFile"
      via: "import and function call"
      pattern: "execFile\\('command'"
    - from: "src/test/codeAgents/codex-agent.test.ts"
      to: "src/codeAgents/CodexAgent.ts"
      via: "import and method calls"
      pattern: "import.*CodexAgent"
    - from: "src/test/codeAgents/agent-factory.test.ts"
      to: "src/codeAgents/factory.ts"
      via: "import and function calls"
      pattern: "import.*factory"
---

<objective>
Fix 4 carried-over security/correctness issues and write unit tests for CodexAgent and agent factory.

Purpose: Security fixes must land before tests so tests cover corrected behavior. CodexAgent and factory are the core new code from Phases 2-3 that needs test coverage.
Output: Fixed production code + 2 new test files covering command building, permission mapping, session capture, UUID validation, factory creation, CLI availability checks.
</objective>

<execution_context>
@/Users/filipejesus/.claude/get-shit-done/workflows/execute-plan.md
@/Users/filipejesus/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-testing-validation/05-RESEARCH.md

@src/codeAgents/factory.ts
@src/codeAgents/CodexAgent.ts
@src/codeAgents/CodeAgent.ts
@src/AgentSessionProvider.ts
@src/test/testSetup.ts
@src/test/workflow/code-agent.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix 4 carried-over security/correctness issues</name>
  <files>
    src/codeAgents/factory.ts
    src/codeAgents/CodexAgent.ts
    src/AgentSessionProvider.ts
  </files>
  <action>
    Fix all 4 issues identified in code reviews from Phases 2-4. These MUST be fixed before writing tests so the tests verify corrected behavior.

    **1. Command injection in isCliAvailable() (factory.ts):**
    - Change `import { exec } from 'child_process'` to `import { execFile } from 'child_process'`
    - Replace `exec(\`command -v ${cliCommand}\`, { shell: '/bin/sh', timeout: 5000 }, ...)` with `execFile('command', ['-v', cliCommand], { shell: true, timeout: 5000 }, ...)`
    - Per user decision: use execFile with args array to eliminate shell injection entirely. `shell: true` enables the `command` shell builtin without injection risk because args are passed as an array, not interpolated into a string.

    **2. Hardcoded /bin/sh shell path (factory.ts):**
    - This is fixed simultaneously with issue 1 above: the `shell: '/bin/sh'` becomes `shell: true`, letting Node.js resolve the shell automatically for cross-platform compatibility.

    **3. AgentStatusState type missing 'active' (AgentSessionProvider.ts):**
    - Change `export type AgentStatusState = 'working' | 'waiting_for_user' | 'idle' | 'error';` to `export type AgentStatusState = 'working' | 'waiting_for_user' | 'active' | 'idle' | 'error';`
    - Also add `'active'` to the `VALID_STATUS_VALUES` array on line 19: `const VALID_STATUS_VALUES: AgentStatusState[] = ['working', 'waiting_for_user', 'active', 'idle', 'error'];`
    - This is needed because hookless terminal tracking writes `status: 'active'` in TerminalService.ts trackHooklessTerminal().

    **4. Path traversal in captureSessionId (CodexAgent.ts):**
    - Inside the `for (const file of files)` loop in captureSessionId(), after constructing `const filePath = path.join(sessionsDir, file);`, add a path traversal check:
      ```
      const resolvedPath = path.resolve(filePath);
      if (!resolvedPath.startsWith(sessionsDir + path.sep) && resolvedPath !== sessionsDir) {
          continue; // Skip files that resolve outside sessions directory
      }
      ```
    - This prevents directory traversal via filenames like `../../etc/passwd`. Use `path.resolve()` + prefix check approach per research recommendation.
    - Apply the same check to the second `path.join(sessionsDir, newestFile)` usage further down (the readFile call). Or better: reuse the already-constructed `filePath` from candidates array by storing it. Modify the candidates array to store `{ file, mtime, filePath }` and use `candidates[0].filePath` for the readFile call instead of reconstructing with path.join.
  </action>
  <verify>
    Run `npm run compile` to verify TypeScript compilation succeeds with all changes. Grep for `exec(\`` in factory.ts to confirm no exec with template literal remains. Grep for `'active'` in AgentSessionProvider.ts to confirm type includes it. Grep for `path.resolve` in CodexAgent.ts to confirm traversal check exists.
  </verify>
  <done>
    All 4 security/correctness issues fixed: factory uses execFile with shell:true, AgentStatusState includes 'active', captureSessionId validates resolved paths stay within sessions directory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write CodexAgent and agent factory unit tests</name>
  <files>
    src/test/codeAgents/codex-agent.test.ts
    src/test/codeAgents/agent-factory.test.ts
  </files>
  <action>
    Create two new test files in `src/test/codeAgents/` directory (create the directory first). Follow existing codebase test patterns from `src/test/workflow/code-agent.test.ts` and `src/test/testSetup.ts`.

    **File 1: src/test/codeAgents/codex-agent.test.ts**

    Import CodexAgent from `../../codeAgents/CodexAgent`. Use assert for assertions, sinon for stubs, fs/promises for mocking.

    Suite: "CodexAgent Command Building"
    - Test buildStartCommand with acceptEdits permission: verify output includes `codex`, `--sandbox workspace-write`, `--ask-for-approval on-failure`
    - Test buildStartCommand with bypassPermissions: verify `--sandbox danger-full-access`, `--ask-for-approval never`
    - Test buildStartCommand with prompt containing single quotes: verify escaping produces `'Fix user'\''s code'` pattern
    - Test buildStartCommand with no permission mode and no prompt: verify output is just `codex`
    - Test buildResumeCommand with valid UUID: verify output is `codex resume <uuid>`
    - Test buildResumeCommand with invalid UUID: verify it throws Error with message matching /Invalid session ID format/

    Suite: "CodexAgent Permission Modes"
    - Test getPermissionModes returns 2 modes with ids 'acceptEdits' and 'bypassPermissions'
    - Test validatePermissionMode accepts valid modes, rejects 'invalid' and 'default'
    - Test getPermissionFlag returns correct dual-flag string for each mode

    Suite: "CodexAgent Session Capture" (uses sinon stubs on fs/promises)
    - Setup: stub fs.readdir, fs.stat, fs.readFile on the `fs/promises` module. Teardown: restore all stubs.
    - Test captures session ID from newest file when file appears after beforeTimestamp. Configure readdir to return a file, stat to return mtime after beforeTimestamp, readFile to return JSONL with session_id field. Assert returns correct UUID.
    - Test returns null on timeout when no files appear (readdir always returns empty array). Use short timeout (200ms) and pollInterval (50ms) for fast test.
    - Test skips files modified before beforeTimestamp. Configure stat to return mtime BEFORE beforeTimestamp. Assert returns null (with short timeout).
    - Test path traversal protection: configure readdir to return `['../../etc/passwd', 'valid-session.jsonl']`. Configure stat/readFile for valid-session.jsonl only. Assert it skips the traversal filename and returns the valid session ID.

    **File 2: src/test/codeAgents/agent-factory.test.ts**

    Import getAgent, getAvailableAgents, isCliAvailable from `../../codeAgents/factory`. Use sinon for stubbing child_process.execFile.

    Suite: "Agent Factory"
    - Test getAgent('claude') returns ClaudeCodeAgent instance (check agent.name === 'claude')
    - Test getAgent('codex') returns CodexAgent instance (check agent.name === 'codex')
    - Test getAgent('unknown') returns null
    - Test getAvailableAgents() returns array containing 'claude' and 'codex'
    - Test getAgent returns same instance on repeated calls (singleton check: getAgent('claude') === getAgent('claude'))

    Suite: "CLI Availability Check"
    - Setup: stub `require('child_process').execFile` with sinon. Teardown: restore.
    - Note: The factory module imports execFile at the top level. To stub it, use `sinon.stub(require('child_process'), 'execFile')`. The function calls its callback argument -- use `callsArgWith` to simulate success/failure.
    - Test isCliAvailable returns true when CLI exists: stub execFile to call callback arg (index 3) with (null, '/usr/local/bin/codex', ''). Assert resolves to true.
    - Test isCliAvailable returns false when CLI missing: stub execFile to call callback arg (index 3) with (new Error('ENOENT')). Assert resolves to false.
    - Test isCliAvailable uses shell:true option: after calling isCliAvailable, inspect stub.firstCall.args[2] (the options object). Assert options.shell === true (NOT '/bin/sh').
    - Test isCliAvailable passes command as args array (injection protection): call with malicious input 'codex; rm -rf /'. Inspect stub.firstCall.args: assert args[0] === 'command', args[1] deep equals ['-v', 'codex; rm -rf /'] (the semicolon is NOT interpreted as command separator because it's in an array element).

    Important: After writing tests, the factory singleton cache may cause test pollution. The factory uses a module-level `instances` Map. Between test suites, the cache persists. For the factory tests, call getAgent tests first (they populate cache), then singleton test verifies same instance. For CLI availability tests, the stubs on child_process work independently of the cache. If needed, note this is acceptable because we test getAgent returns the right type, and singleton behavior is verified explicitly.
  </action>
  <verify>
    Run `npm test` to verify all new tests pass alongside existing tests. Check test output shows the new test suites: "CodexAgent Command Building", "CodexAgent Permission Modes", "CodexAgent Session Capture", "Agent Factory", "CLI Availability Check".
  </verify>
  <done>
    Two new test files created covering: CodexAgent command building (6 tests), permission modes (3 tests), session ID capture with mocked fs (4 tests), agent factory creation (5 tests), CLI availability with injection protection (4 tests). All tests pass. Total: ~22 new tests.
  </done>
</task>

</tasks>

<verification>
1. `npm run compile` succeeds (TypeScript compilation with all fixes)
2. `npm test` passes (all existing + new tests)
3. `grep -r "exec(\`" src/codeAgents/factory.ts` returns no matches (no exec with template literal)
4. `grep "execFile" src/codeAgents/factory.ts` confirms execFile usage
5. `grep "'active'" src/AgentSessionProvider.ts` confirms type includes active
6. `grep "path.resolve" src/codeAgents/CodexAgent.ts` confirms traversal check
7. New test files exist: src/test/codeAgents/codex-agent.test.ts, src/test/codeAgents/agent-factory.test.ts
</verification>

<success_criteria>
- All 4 carried-over issues fixed in production code
- CodexAgent unit tests cover command building, permission mapping, UUID validation, session capture, and path traversal protection
- Factory unit tests cover agent creation, singleton behavior, CLI availability checks, and command injection prevention
- All tests (existing + new) pass via `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/05-testing-validation/05-01-SUMMARY.md`
</output>
